#Область ПрограммныйИнтерфейс

// Возвращает структуру с данными по основным и дополнительным работам.
//
// Параметры:
//  ЗаданиеНаПеревозкуГруза		 - ДокументСсылка	 - Ссылка на элемент.
//  АдресПогрузки				 - СправочникСсылка	 - Ссылка на элемент.
//  АдресРазгрузки				 - СправочникСсылка	 - Ссылка на элемент.
//  мсвГрузовыхМест				 - Массив			 - Массив ссылок.
//  ПолучитьДопРаботы			 - Булево			 - Флаг выполнения.
//  ВариантФормированияМаршрута	 - ПеречислениеСсылка.упВариантыФормированияМаршрута - Полный или самовывоз, при самовывозе формируются только работы связанные с погрузкой.
//  ЧасовойПоясРейса			 - СправочникСсылка.упЧасовыеПояса - Часовой пояс в котором выполняется рейс, все временные окна заданий будут преобразованы к нему.
// 
// Возвращаемое значение:
//  Структура - Данные результата обработки.
//
Функция ПолучитьРаботыПоЗаданию(ЗаданиеНаПеревозкуГруза, АдресПогрузки, АдресРазгрузки = Неопределено, мсвГрузовыхМест = Неопределено, ПолучитьДопРаботы = Истина, ВариантФормированияМаршрута = Неопределено, ЧасовойПоясРейса = Неопределено) Экспорт
	
	сткРезультат = Новый Структура("ОсновныеРаботы, ДополнительныеРаботы, ПолучениеПередачаДокументов, ВременноеОкноНачало, ВременноеОкноОкончание");
	
	ВариантМаршрутаПолный =  упКорректировкаМаршрута.ВариантФормированияМаршрутаПолный(ВариантФормированияМаршрута);
	
	// Основные работы.
	мсвОсновныеРаботы = Новый Массив;
	
	текТипПогрузка 			= ПредопределенноеЗначение("Перечисление.упТипыОпераций.Погрузка");
	текТипВыемкаЦенностей	= ПредопределенноеЗначение("Перечисление.упТипыОпераций.ВыемкаЦенностей");
	текТипРазгрузка 		= ПредопределенноеЗначение("Перечисление.упТипыОпераций.Разгрузка");
	текТипПередачаЦенностей	= ПредопределенноеЗначение("Перечисление.упТипыОпераций.ПередачаЦенностей");
	
	текВремяРаботПогрузки  = 0;
	текВремяРаботРазгрузки = 0;
	
	сткВременнойИнтервалПогрузки 		= упЗаданиеНаПеревозку.ПолучитьВременныеИнтервалыЗадания(ЗаданиеНаПеревозкуГруза);
	ВедетсяРаботаВРазныхЧасовыхПоясах 	= ПолучитьФункциональнуюОпцию("упВедетсяРаботаВРазныхЧасовыхПоясах");
	
	// Время работ.
	Если НЕ мсвГрузовыхМест = Неопределено Тогда
		
		мсвАдреса = Новый Массив();
		мсвАдреса.Добавить(Новый Структура("ВидАдреса, ТипОперации", АдресПогрузки.ВидАдреса, текТипПогрузка));
		Если ВариантМаршрутаПолный Тогда
			мсвАдреса.Добавить(Новый Структура("ВидАдреса, ТипОперации", АдресРазгрузки.ВидАдреса, текТипРазгрузка));                                       
		КонецЕсли;
		
		сткИменаРеквизитов = Новый Структура();
		сткИменаРеквизитов.Вставить("ПараметрыВводаИнформацииОГрузовыхМестах", "ВидПеревозки.ПараметрыВводаИнформацииОГрузовыхМестах");
		сткИменаРеквизитов.Вставить("ИспользуютсяУслугиИнкассации", "ВидПеревозки.ИспользуютсяУслугиИнкассации");
		сткИменаРеквизитов.Вставить("СпособУчетаИнкассируемыхЦенностей", "ВидПеревозки.СпособУчетаИнкассируемыхЦенностей");
		сткИменаРеквизитов.Вставить("ЧасовойПояс", "ЧасовойПояс");
		
		сткРеквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ЗаданиеНаПеревозкуГруза, сткИменаРеквизитов);
		ФормироватьПоГрузовымМестам = (сткРеквизиты.ПараметрыВводаИнформацииОГрузовыхМестах <> Перечисления.упПараметрыВводаИнформацииОГрузовыхМестах.НеВводится);
		
		Если ПолучитьФункциональнуюОпцию("упИспользуютсяУслугиИнкассации") 
					И сткРеквизиты.ИспользуютсяУслугиИнкассации 
					И сткРеквизиты.СпособУчетаИнкассируемыхЦенностей = Перечисления.упСпособыУчетаИнкассируемыхЦенностей.СТочностьюДоГрузовыхМест Тогда
			мсвАдреса.Добавить(Новый Структура("ВидАдреса, ТипОперации", АдресПогрузки.ВидАдреса, текТипВыемкаЦенностей));
			Если ВариантМаршрутаПолный Тогда
				мсвАдреса.Добавить(Новый Структура("ВидАдреса, ТипОперации", АдресРазгрузки.ВидАдреса, текТипПередачаЦенностей));                                       	
			КонецЕсли;
		КонецЕсли;
		
		ЧасовойПоясЗадания = сткРеквизиты.ЧасовойПояс;
		тбзВремя = упЗаданиеНаПеревозку.ПолучитьВремяРаботыПоГрузовымМестам(мсвАдреса, мсвГрузовыхМест, ФормироватьПоГрузовымМестам);
		
		Если НЕ тбзВремя = Неопределено и тбзВремя.Количество()>0 Тогда
			Для каждого текСтрока Из тбзВремя Цикл
				Если текСтрока.ТипОперации =  текТипПогрузка
						ИЛИ текСтрока.ТипОперации =  текТипВыемкаЦенностей Тогда
					ВременноеОкноНачало 	= сткВременнойИнтервалПогрузки.Погрузка.Начало;
					ВременноеОкноОкончание	= сткВременнойИнтервалПогрузки.Погрузка.Окончание;	
				Иначе	
					ВременноеОкноНачало 	= сткВременнойИнтервалПогрузки.Разгрузка.Начало;	
					ВременноеОкноОкончание	= сткВременнойИнтервалПогрузки.Разгрузка.Окончание;	
				КонецЕсли;
				
				Если ВедетсяРаботаВРазныхЧасовыхПоясах 
					И ЗначениеЗаполнено(ЧасовойПоясЗадания) 
					И ЗначениеЗаполнено(ЧасовойПоясРейса) 
					И НЕ ЧасовойПоясЗадания = ЧасовойПоясРейса Тогда
					Если ЗначениеЗаполнено(ВременноеОкноНачало) Тогда
						ВременноеОкноНачало		= упСервисныеФункции.ПеревестиВремяПриСменеЧасовогоПояса(ВременноеОкноНачало, ЧасовойПоясЗадания, ЧасовойПоясРейса); 	
					КонецЕсли;
					Если ЗначениеЗаполнено(ВременноеОкноОкончание) Тогда
						ВременноеОкноОкончание	= упСервисныеФункции.ПеревестиВремяПриСменеЧасовогоПояса(ВременноеОкноОкончание, ЧасовойПоясЗадания, ЧасовойПоясРейса); 	
					КонецЕсли;
				КонецЕсли;
				
				сткРабота = Новый Структура("Задание, ГрузовоеМесто, Тара, Операция, ВремяРабот, ВременноеОкноНачало, ВременноеОкноОкончание, КоличествоГрузов, Сумма, ИнкассацияЗаГруз, ЭтоКонтейнер", 
									ЗаданиеНаПеревозкуГруза, 
									текСтрока.ГрузовоеМесто,
									текСтрока.Тара,
									текСтрока.ТипОперации,
									текСтрока.ВремяРабот,
									ВременноеОкноНачало,
									ВременноеОкноОкончание,
									текСтрока.КоличествоГрузов,
									?(текСтрока.ЭтоИнкассация, текСтрока.Сумма, 0),
									текСтрока.ИнкассацияЗаГруз,
									текСтрока.ЭтоКонтейнер);
				мсвОсновныеРаботы.Добавить(сткРабота);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
		
	// Дополнительные работы.
	мсвДополнительныеРаботы = Новый Массив;
	
	Если ПолучитьДопРаботы Тогда
		
		тбзДопОперации = упЗаданиеНаПеревозку.ПолучитьВремяПоДопОперациям(ЗаданиеНаПеревозкуГруза);
		
		Для каждого текСтрока Из тбзДопОперации Цикл
			сткРабота = Новый Структура("Задание, ДополнительнаяОперация, Операция, ВлияющаяОперация, ВремяРабот, ВременноеОкноНачало, ВременноеОкноОкончание, КоличествоДопОпераций", 
											ЗаданиеНаПеревозкуГруза,
											текСтрока.ДополнительнаяОперация,
											Перечисления.упТипыОпераций.ДополнительнаяОперация, 
											текСтрока.ТипОперации,
											текСтрока.ВремяРабот,
											сткВременнойИнтервалПогрузки.Погрузка.Начало,
											сткВременнойИнтервалПогрузки.Погрузка.Окончание,
											текСтрока.КоличествоДопОпераций);
			мсвДополнительныеРаботы.Добавить(сткРабота);								
			
		КонецЦикла;
	КонецЕсли;
	
	// Передача / получение регламентных документов.
	мсвПолучениеПередачаДокументов = Новый Массив;
	
	сткРезультат.ОсновныеРаботы 		     = мсвОсновныеРаботы;
	сткРезультат.ДополнительныеРаботы 	     = мсвДополнительныеРаботы;
	сткРезультат.ПолучениеПередачаДокументов = мсвПолучениеПередачаДокументов;
	
	Возврат сткРезультат;
	
КонецФункции

// Возвращает структуру с данными получения по документу.
//
// Параметры:
//  ЗаданиеНаПеревозкуГруза - ДокументСсылка - Ссылка на элемент.
//
// Возвращаемое значение:
//  Структура - Данные результата обработки.
//
Функция ПолучитьДанныеПолучениеПередачаДокументов(ЗаданиеНаПеревозкуГруза) Экспорт
	
	сткВозврат = Новый Структура("ПолучениеПередачаДокументов, КонтрольныеТочкиВозвратаДокументов", Новый Массив, Новый Массив);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", ЗаданиеНаПеревозкуГруза);
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВЫБОР
	|		КОГДА упЗаданиеНаПеревозкуГруза.Заказчик.ПакетРегламентныхДокументов = ЗНАЧЕНИЕ(Справочник.упПакетыРегламентныхДокументов.ПустаяСсылка)
	|			ТОГДА упЗаданиеНаПеревозкуГруза.ВидПеревозки.ПакетРегламентныхДокументов
	|		ИНАЧЕ упЗаданиеНаПеревозкуГруза.Заказчик.ПакетРегламентныхДокументов
	|	КОНЕЦ КАК ПакетРегламентныхДокументов,
	|	упЗаданиеНаПеревозкуГруза.Заказчик.АдресВозвратаДокументов КАК АдресВозвратаДокументов,
	|	упЗаданиеНаПеревозкуГруза.АдресОтправления
	|ПОМЕСТИТЬ втПакетРегламентныхДокументов
	|ИЗ
	|	Документ.упЗаданиеНаПеревозкуГруза КАК упЗаданиеНаПеревозкуГруза
	|ГДЕ
	|	упЗаданиеНаПеревозкуГруза.Ссылка = &Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ПакетДокументов.ТипРегламентногоДокумента,
	|	ПакетДокументов.Участник,
	|	ПакетДокументов.КоличествоПолучитьОтУчастника,
	|	ПакетДокументов.КоличествоПередатьУчастнику,
	|	ПакетДокументов.ВозвратДокументовПослеИсполненияРейса
	|ПОМЕСТИТЬ втДокументыПакетов
	|ИЗ
	|	втПакетРегламентныхДокументов КАК втПакет
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.упПакетыРегламентныхДокументов.ПакетДокументов КАК ПакетДокументов
	|		ПО втПакет.ПакетРегламентныхДокументов = ПакетДокументов.Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.ПолучениеДокументов) КАК Операция,
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.Погрузка) КАК ВлияющаяОперация,
	|	втДокументыПакетов.ТипРегламентногоДокумента,
	|	втДокументыПакетов.КоличествоПолучитьОтУчастника КАК КоличествоЭкземпляровДокумента
	|ПОМЕСТИТЬ втПолучениеПередачаДокументов
	|ИЗ
	|	втДокументыПакетов КАК втДокументыПакетов
	|ГДЕ
	|	втДокументыПакетов.Участник = ЗНАЧЕНИЕ(Перечисление.упУчастникиДокументооборотаПеревозки.Грузоотправитель)
	|	И втДокументыПакетов.КоличествоПолучитьОтУчастника > 0
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.ПередачаДокументов),
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.Разгрузка),
	|	втДокументыПакетов.ТипРегламентногоДокумента,
	|	втДокументыПакетов.КоличествоПередатьУчастнику
	|ИЗ
	|	втДокументыПакетов КАК втДокументыПакетов
	|ГДЕ
	|	втДокументыПакетов.Участник = ЗНАЧЕНИЕ(Перечисление.упУчастникиДокументооборотаПеревозки.Грузополучатель)
	|	И втДокументыПакетов.КоличествоПередатьУчастнику > 0
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.ПолучениеДокументов),
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.Разгрузка),
	|	втДокументыПакетов.ТипРегламентногоДокумента,
	|	втДокументыПакетов.КоличествоПолучитьОтУчастника
	|ИЗ
	|	втДокументыПакетов КАК втДокументыПакетов
	|ГДЕ
	|	втДокументыПакетов.Участник = ЗНАЧЕНИЕ(Перечисление.упУчастникиДокументооборотаПеревозки.Грузополучатель)
	|	И втДокументыПакетов.КоличествоПолучитьОтУчастника > 0
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.ПолучениеДокументов),
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.Погрузка),
	|	втДокументыПакетов.ТипРегламентногоДокумента,
	|	втДокументыПакетов.КоличествоПолучитьОтУчастника
	|ИЗ
	|	втДокументыПакетов КАК втДокументыПакетов
	|ГДЕ
	|	втДокументыПакетов.Участник = ЗНАЧЕНИЕ(Перечисление.упУчастникиДокументооборотаПеревозки.Заказчик)
	|	И НЕ втДокументыПакетов.ВозвратДокументовПослеИсполненияРейса
	|	И втДокументыПакетов.КоличествоПолучитьОтУчастника > 0
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	втПолучениеПередачаДокументов.Операция,
	|	втПолучениеПередачаДокументов.ВлияющаяОперация,
	|	втПолучениеПередачаДокументов.ТипРегламентногоДокумента,
	|	СУММА(втПолучениеПередачаДокументов.КоличествоЭкземпляровДокумента) КАК КоличествоЭкземпляровДокумента
	|ИЗ
	|	втПолучениеПередачаДокументов КАК втПолучениеПередачаДокументов
	|
	|СГРУППИРОВАТЬ ПО
	|	втПолучениеПередачаДокументов.Операция,
	|	втПолучениеПередачаДокументов.ВлияющаяОперация,
	|	втПолучениеПередачаДокументов.ТипРегламентногоДокумента
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	втПакет.АдресВозвратаДокументов КАК АдресВозвратаДокументов,
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.ПередачаДокументов) КАК Операция,
	|	втДокументыПакетов.ТипРегламентногоДокумента КАК ТипРегламентногоДокумента,
	|	втДокументыПакетов.КоличествоПередатьУчастнику КАК КоличествоЭкземпляровДокумента
	|ИЗ
	|	втПакетРегламентныхДокументов КАК втПакет
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ втДокументыПакетов КАК втДокументыПакетов
	|		ПО (втДокументыПакетов.Участник = ЗНАЧЕНИЕ(Перечисление.упУчастникиДокументооборотаПеревозки.Заказчик))
	|			И (НЕ втДокументыПакетов.ВозвратДокументовПослеИсполненияРейса)
	|			И (втДокументыПакетов.КоличествоПередатьУчастнику > 0)
	|			И (втПакет.АдресВозвратаДокументов <> ЗНАЧЕНИЕ(Справочник.упАдреса.ПустаяСсылка))
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	втПакет.АдресОтправления,
	|	ЗНАЧЕНИЕ(Перечисление.упТипыОпераций.ПередачаДокументов),
	|	втДокументыПакетов.ТипРегламентногоДокумента,
	|	втДокументыПакетов.КоличествоПередатьУчастнику
	|ИЗ
	|	втПакетРегламентныхДокументов КАК втПакет
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ втДокументыПакетов КАК втДокументыПакетов
	|		ПО (втДокументыПакетов.Участник = ЗНАЧЕНИЕ(Перечисление.упУчастникиДокументооборотаПеревозки.Грузоотправитель))
	|			И (втДокументыПакетов.КоличествоПередатьУчастнику > 0)";
	Результат = Запрос.ВыполнитьПакет();
	КоличествоТаблиц = Результат.Количество();
	
	Если Не Результат[КоличествоТаблиц - 2].Пустой() Тогда
		Выборка = Результат[КоличествоТаблиц - 2].Выбрать();
		Пока Выборка.Следующий() Цикл
			сткРабота = Новый Структура("Задание, Операция, ВлияющаяОперация, ТипРегламентногоДокумента, КоличествоЭкземпляровДокумента");
			ЗаполнитьЗначенияСвойств(сткРабота, Выборка);
			сткРабота.Задание = ЗаданиеНаПеревозкуГруза;
			сткВозврат.ПолучениеПередачаДокументов.Добавить(сткРабота);
		КонецЦикла; 
	КонецЕсли; 
	
	Если Не Результат[КоличествоТаблиц - 1].Пустой() Тогда
		Выборка = Результат[КоличествоТаблиц - 1].Выбрать();
		Пока Выборка.Следующий() Цикл
			сткКонтрольнаяТочка = Новый Структура("АдресВозвратаДокументов, Операция, ТипРегламентногоДокумента, КоличествоЭкземпляровДокумента");
			ЗаполнитьЗначенияСвойств(сткКонтрольнаяТочка, Выборка);
			сткВозврат.КонтрольныеТочкиВозвратаДокументов.Добавить(сткКонтрольнаяТочка);
		КонецЦикла; 
	КонецЕсли;
	
	Возврат сткВозврат;

КонецФункции 

// Определят коэффициент времени географической зоны.
//
// Параметры:
//  Адрес - СправочникСсылка - Ссылка на элемент.
//  ДеньНедели - Число - Число дня.
//
// Возвращаемое значение:
//  Структура - Данные результата обработки.
//
Функция _ПолучитьКоэффициентВремениРабочейЗоны(Адрес, ДеньНедели) Экспорт
	Возврат Справочники.упАдреса._ПолучитьКоэффициентВремениРабочейЗоны(Адрес, ДеньНедели)	
КонецФункции

// Заполнение параметров текущей точки переданного маршрута.
//
// Параметры:
//  Маршрут										 - ТаблицаЗначений	 - Таблица маршрута.
//  Работы										 - ТаблицаЗначений	 - Таблица Работ.
//  ИндексТекущейТочки - Число - индекс.
//  ИндексТочкиНачалаПересчета						 - Число			 - индекс.
//  НачалоРейса									 - Дата			 - дата начала.
//  КоэффициентПереводаВЧасы							 - Число			 - Коэффициент.
//  ВызыватьМаршрутизацию							 - Булево			 - Флаг вызывать.
//  ДополнительныеПараметры							 - Структура		 - Параметры.
//  ПересчитыватьПредыдущиеТочки						 - Булево			 - Флаг пересчета.
//  ПересчитыватьТекущуюТочку							 - Булево			 - Флаг пересчета.
//  ПересчитыватьСледующиеТочки						 - Булево			 - Флаг пересчета.
//  ПересчитыватьПлановоеВремяПосещенияТочекМаршрута		 - Булево			 - Флаг пересчета.
//  ДопустимыйПериодРассогласованностиСФактическимиДанными	 - Число			 - допустимый период.
//  ПересчитыватьТекущуюТочкуКромеПлановогоПрибытия		 - Булево			 - Флаг пересчета текущей точки.
//  			Пересчитываются все параметры, кроме планового прибытия в точку.
//  ВидПеревозки									 - Справочник.упВидыПеревозок	 - Значение вида перевозки по Рейсу. Необходим при использовании режимов труда для определения параметров перерывов и временных приращений.
//  КоэффициентРасчетаВремениВПути						 - Число					 - коэффициент.
//  ЧасовойПояс									 - СправочникСсылка.упЧасовыеПояса  - часовое пояс.
//
Процедура СпланироватьЗадачиПоМаршруту(Маршрут, Работы, ИндексТочкиНачалаПересчета = 0, НачалоРейса = Неопределено, 
										КоэффициентПереводаВЧасы = 3600, 
										ВызыватьМаршрутизацию = Неопределено, 
										ДополнительныеПараметры = Неопределено, 
										ПересчитыватьПредыдущиеТочки = Истина, 
										ПересчитыватьТекущуюТочку = Ложь, 
										ПересчитыватьСледующиеТочки = Истина,
										ПересчитыватьПлановоеВремяПосещенияТочекМаршрута = Ложь,
										ДопустимыйПериодРассогласованностиСФактическимиДанными = 0,
										ПересчитыватьТекущуюТочкуКромеПлановогоПрибытия = Истина,
										ВидПеревозки = Неопределено,
										КоэффициентРасчетаВремениВПути = 0,
										Знач ЧасовойПояс = Неопределено,
										Рейс = Неопределено) Экспорт
	Если Ложь Тогда // Для контекстной подсказки
	    ВидПеревозки = Справочники.упВидыПеревозок.ПустаяСсылка();
		ЧасовойПояс = Справочники.упЧасовыеПояса.ПустаяСсылка();
	КонецЕсли;
	Если Истина
		И ПолучитьФункциональнуюОпцию("упВедетсяРаботаВРазныхЧасовыхПоясах")
		И Не ЗначениеЗаполнено(ЧасовойПояс) 
	Тогда
		//Если Не ЗначениеЗаполнено(ЧасовойПояс) Тогда
		//	ЧасовойПояс = упСервисныеФункции.ПолучитьЧасовойПоясПользователя(); // тут структура возвращается
		//КонецЕсли; 
		Если Не ЗначениеЗаполнено(ЧасовойПояс) Тогда
			ЧасовойПояс = упСервисныеФункции.ТекущийЧасовойПояс();
		КонецЕсли; 
	КонецЕсли; 
	УчитыватьРежимТрудаИОтдыхаСотрудников = Истина
		И ПолучитьФункциональнуюОпцию("упУчитыватьРежимТрудаИОтдыхаСотрудников") 
		И ВидПеревозки <> Неопределено 
		И ЗначениеЗаполнено(ВидПеревозки.ПравилоРежимаТрудаИОтдыхаСотрудников);
	Если УчитыватьРежимТрудаИОтдыхаСотрудников Тогда
		ТаблицаПерерывовИПриращений = ПолучитьТаблицуПерерывовИПриращений(ВидПеревозки.ПравилоРежимаТрудаИОтдыхаСотрудников);
		
		СтруктураПерерывовИПриращений = Новый Структура("ТаблицаПерерывовИПриращений, ПродолжительностьРабочегоДняС, 
				|ПродолжительностьРабочейНеделиС, ПродолжительностьОтдыхаВРабочемДнеС, ПродолжительностьКалендарныхСутокС,
				|НовыеСутки, ФактПредыдущий, ОтдыхПредыдущий, ПлановоеВремяДоТочки, ДатаРасчета", 
				ТаблицаПерерывовИПриращений, ВидПеревозки.ПравилоРежимаТрудаИОтдыхаСотрудников.ПродолжительностьРабочегоВремениДеньЧ*3600, 
				ВидПеревозки.ПравилоРежимаТрудаИОтдыхаСотрудников.ПродолжительностьРабочегоВремениОднаНеделяЧ*3600, 0, 24*3600,
				Ложь, 0, 0, 0, '00010101');
				
		Для Каждого СтрокаРезультат Из ТаблицаПерерывовИПриращений Цикл
			Если НЕ СтрокаРезультат.НовыеСутки Тогда
				СтруктураПерерывовИПриращений.ПродолжительностьОтдыхаВРабочемДнеС = СтруктураПерерывовИПриращений.ПродолжительностьОтдыхаВРабочемДнеС + СтрокаРезультат.Приращение;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Заккоментировано по причине того что колонка "СтрокаНомер" уже не заполняется
	//Если Истина
	//	Ложь
	//	Или ТипЗнч(Работы) = Тип("ТаблицаЗначений") 
	//	Или ТипЗнч(Работы) = Тип("ДанныеФормыКоллекция") 
	//Тогда
	//	Работы.Сортировать("СтрокаНомер");
	//КонецЕсли;	
	
	КоличествоТочек 	= Маршрут.Количество();
	ИндексТекущейТочки	= ИндексТочкиНачалаПересчета;
	
	// Если в маршуте нет точек или передан некорректный индекс
	Если КоличествоТочек = 0 ИЛИ ИндексТекущейТочки < 0 ИЛИ ИндексТекущейТочки >= КоличествоТочек Тогда
		Возврат;
	КонецЕсли;
	
	ТочкаТекущая = ТекущаяТочка(Маршрут, ИндексТекущейТочки, КоличествоТочек);
	Если Ложь Тогда // Для контекстной подсказки
	    ТочкаТекущая = РегистрыСведений.упМаршрутПоРейсу.СоздатьМенеджерЗаписи();
	КонецЕсли;
	
	// Если все точки отменены
	Если ТочкаТекущая = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТочкаПредыдущая = ПредыдущаяТочка(Маршрут, ИндексТекущейТочки);
	Если Ложь Тогда // Для контекстной подсказки
	    ТочкаПредыдущая = РегистрыСведений.упМаршрутПоРейсу.СоздатьМенеджерЗаписи();
	КонецЕсли;
	Если НачалоРейса = Неопределено Тогда
		НачалоРейса = ТекущаяДатаСеанса();
	КонецЕсли;
	
	ПлановоеУбытиеИзПредыдущейТочки = Неопределено;
	
	// Определяется плановое прибытие в текущую точку
	Если ИндексТекущейТочки > 0 И ПересчитыватьТекущуюТочку Тогда
		Если ТочкаПредыдущая = Неопределено Тогда
			ПлановоеУбытиеИзПредыдущейТочки	= НачалоРейса;
		Иначе	
			// Если пересчитывается плановое время и отклонение больше заданного
			Если ПринятьФактическоеУбытиеИзТочкиЗаПлановое(ТочкаПредыдущая, ПересчитыватьПлановоеВремяПосещенияТочекМаршрута, ДопустимыйПериодРассогласованностиСФактическимиДанными) Тогда
				ПлановоеУбытиеИзПредыдущейТочки	= ТочкаПредыдущая.УбытиеФакт;
			Иначе
				ПлановоеУбытиеИзПредыдущейТочки	= ТочкаПредыдущая.ПлановоеУбытие;	
			КонецЕсли;
		КонецЕсли;
	Иначе	
		ПлановоеУбытиеИзПредыдущейТочки	= ТочкаТекущая.ПлановоеПрибытие;	
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ПлановоеУбытиеИзПредыдущейТочки) Тогда
		воНачало = ТочкаТекущая.ВременноеОкноНачало;
		Если ЗначениеЗаполнено(воНачало) = '00010101' Тогда
			ПлановоеУбытиеИзПредыдущейТочки = Макс(НачалоРейса, воНачало);
		Иначе
			ПлановоеУбытиеИзПредыдущейТочки = НачалоРейса;
		КонецЕсли;
	КонецЕсли;
	
	ТекущееЗначениеВызыватьМаршрутизацию = Ложь;
	
	Если ВызыватьМаршрутизацию = Неопределено Тогда
		ТекущееЗначениеВызыватьМаршрутизацию = ВидПеревозки.ОбращатьсяКМаршрутизаторуПриИзмененииМаршрутаКорректировкойРейса;
	Иначе
		ТекущееЗначениеВызыватьМаршрутизацию = ВызыватьМаршрутизацию;
	КонецЕсли;
	
	соотРасстояния = РассчитатьРасстоянияМеждуТочками(Маршрут, КоэффициентПереводаВЧасы, ТекущееЗначениеВызыватьМаршрутизацию, ДополнительныеПараметры, КоэффициентРасчетаВремениВПути, Рейс);
	ПлановоеПрибытиеВТекущуюТочку = ПлановоеУбытиеИзПредыдущейТочки;
	
	Если НЕ ТочкаПредыдущая = Неопределено Тогда
		ЗаполнитьРастояниеДоПредыдущейТочки(ТочкаПредыдущая, ТочкаТекущая, соотРасстояния);
	КонецЕсли;
	РеквизитыАдресов = ОбщегоНазначения.ЗначенияРеквизитовОбъектов(Маршрут.ВыгрузитьКолонку("Адрес"), "ИспользоватьВремяУбытияИзТочки, ВремяУбытияИзТочки, ДопустимоеОтклонениеУбытияИзТочки, ЧасовойПояс");
	//Если НЕ ТочкаТекущая.Пройдена И 
	Если НЕ ТочкаТекущая.Отменена И ПересчитыватьТекущуюТочкуКромеПлановогоПрибытия Тогда
		//ПлановоеПрибытиеВТекущуюТочку = ПлановоеПрибытиеВТекущуюТочку + ТочкаТекущая.ВремяОтПредыдущейТочки * КоэффициентПереводаВЧасы;
		сткРезультат = СпланироватьЗадачиПоТочке(Работы, ТочкаТекущая, ПлановоеПрибытиеВТекущуюТочку, КоэффициентПереводаВЧасы, ЧасовойПояс, РеквизитыАдресов, ВидПеревозки);
		ЗаполнитьЗначенияСвойств(ТочкаТекущая, сткРезультат);
	КонецЕсли;	
	// Пересчет времени у точек, предшествующих текущей.
	Если Истина
		И ПересчитыватьПредыдущиеТочки 
		И ИндексТекущейТочки > 0 
	Тогда
		Сч = ИндексТекущейТочки - 1;
		Пока Сч >= 0 Цикл
			ТочкаПредыдущая = Маршрут[Сч];
			Если Ложь Тогда // Для контекстной подсказки
			    ТочкаПредыдущая = РегистрыСведений.упМаршрутПоРейсу.СоздатьМенеджерЗаписи();
			КонецЕсли;
			Если НЕ ТочкаПредыдущая.Отменена Тогда
				Если НЕ ТочкаПредыдущая.Пройдена Тогда
					ЗаполнитьРастояниеДоПредыдущейТочки(ТочкаПредыдущая, ТочкаТекущая, соотРасстояния);
					ВремяОтдыхаВПутиОтПредыдущейТочки = 0;
					
					Если ИндексТекущейТочки = 1 И ЗначениеЗаполнено(ТочкаПредыдущая.Гараж) И УчитыватьРежимТрудаИОтдыхаСотрудников Тогда // Костыль для пересчета с гаражом из планирования
						ПлановоеПрибытиеВСледующуюТочку = Дата(1,1,1) + ТочкаТекущая.ВремяОтПредыдущейТочки * КоэффициентПереводаВЧасы;
						СтруктураПерерывовИПриращений.ФактПредыдущий  = 0;
						СтруктураПерерывовИПриращений.ПлановоеВремяДоТочки = ТочкаТекущая.ВремяОтПредыдущейТочки * КоэффициентПереводаВЧасы;
						НовоеПлановоеПрибытиеВСледующуюТочку = упЗаданиеНаПеревозкуВызовСервера.РассчитатьПриращениеВремениКТочке(СтруктураПерерывовИПриращений, ПлановоеПрибытиеВСледующуюТочку, Дата(1,1,1),
							КоэффициентПереводаВЧасы);
						ВремяОтдыхаВПутиОтПредыдущейТочки = НовоеПлановоеПрибытиеВСледующуюТочку - ПлановоеПрибытиеВСледующуюТочку;
						ТочкаТекущая.ВремяОтдыхаВПутиОтПредыдущейТочки = ВремяОтдыхаВПутиОтПредыдущейТочки / КоэффициентПереводаВЧасы;
					КонецЕсли;
					ПлановоеУбытиеЛ = ТочкаТекущая.ПлановоеПрибытие - ВремяОтдыхаВПутиОтПредыдущейТочки - ТочкаТекущая.ВремяОтПредыдущейТочки * КоэффициентПереводаВЧасы;
					РеквизитыАдреса = РеквизитыАдресов[ТочкаПредыдущая.Адрес];
					Если Ложь Тогда // Для контекстной подсказки
					    РеквизитыАдреса = Справочники.упАдреса.ПустаяСсылка();
					КонецЕсли;
					Если Истина
						И Не ТочкаПредыдущая.НеИспользоватьАвторасчетУбытияИзТочки
						И РеквизитыАдреса.ИспользоватьВремяУбытияИзТочки
						И Не (Истина
							И ТочкаПредыдущая.ТипТочки = Перечисления.упТипыТочекМаршрута.ТочкаОтправления
							И ТочкаТекущая.Адрес = ТочкаПредыдущая.Адрес
							И Не ТочкаТекущая.НеИспользоватьАвторасчетУбытияИзТочки)
					Тогда
						АдресВремяУбытияИзТочки = РеквизитыАдреса.ВремяУбытияИзТочки;
						Если ПолучитьФункциональнуюОпцию("упВедетсяРаботаВРазныхЧасовыхПоясах") Тогда
							АдресВремяУбытияИзТочки = упСервисныеФункции.ПеревестиВремяПриСменеЧасовогоПояса(АдресВремяУбытияИзТочки, РеквизитыАдреса.ЧасовойПояс, ЧасовойПояс);
						КонецЕсли; 
						ПлановоеУбытиеФикс = НачалоДня(ПлановоеУбытиеЛ) + (АдресВремяУбытияИзТочки - НачалоДня(АдресВремяУбытияИзТочки));
						Если ПлановоеУбытиеФикс - РеквизитыАдреса.ДопустимоеОтклонениеУбытияИзТочки * 3600 > ПлановоеУбытиеЛ Тогда
							ПлановоеУбытиеФикс = ПлановоеУбытиеФикс - 24*60*60;
						ИначеЕсли ПлановоеУбытиеФикс + РеквизитыАдреса.ДопустимоеОтклонениеУбытияИзТочки * 3600 > ПлановоеУбытиеЛ Тогда
							ПлановоеУбытиеФикс = ПлановоеУбытиеЛ;
						КонецЕсли; 
						ПлановоеУбытиеЛ = ПлановоеУбытиеФикс;
						ПлановоеПрибытиеВТекущуюТочку = ПлановоеУбытиеЛ + ВремяОтдыхаВПутиОтПредыдущейТочки + ТочкаТекущая.ВремяОтПредыдущейТочки * КоэффициентПереводаВЧасы;
						ДопОжиданиеВТекущейТочке = (ТочкаТекущая.ПлановоеПрибытие - ПлановоеПрибытиеВТекущуюТочку) / КоэффициентПереводаВЧасы;
						ТочкаТекущая.ВремяОжиданияВТочке = ТочкаТекущая.ВремяОжиданияВТочке + ДопОжиданиеВТекущейТочке;
						ТочкаТекущая.ПлановоеПрибытие = ПлановоеПрибытиеВТекущуюТочку;
						Если ДопОжиданиеВТекущейТочке > 0 И Сч = ИндексТекущейТочки - 1 Тогда
							ТекстСообщения = НСтр("ru = 'Плановое прибытие в текущую точку было сдвинуто назад из-за наличия окна убытия в адресе предыдущей точки.'");
							ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);
						КонецЕсли; 
					КонецЕсли; 
					сткРезультат = СпланироватьЗадачиПоТочкеСКонца(Работы, ТочкаПредыдущая, ПлановоеУбытиеЛ, КоэффициентПереводаВЧасы, ВидПеревозки);
					ЗаполнитьЗначенияСвойств(ТочкаПредыдущая, сткРезультат);
					
					Если ИндексТекущейТочки = 1 И ЗначениеЗаполнено(ТочкаПредыдущая.Гараж) И УчитыватьРежимТрудаИОтдыхаСотрудников Тогда // Костыль для пересчета с гаражом из планирования
						ПлановоеУбытиеИзПредыдущейТочки = ПлановоеУбытиеЛ;
					КонецЕсли; 
				КонецЕсли;
				ТочкаТекущая = ТочкаПредыдущая;
			Иначе
				СброситьЗначенияТочки(ТочкаПредыдущая);
			КонецЕсли;
			Сч = Сч - 1; 
		КонецЦикла; 
		
	КонецЕсли; 
	
	Если ПересчитыватьСледующиеТочки Тогда
		
		НачалоТекущегоРабочегоДня = ПлановоеУбытиеИзПредыдущейТочки;

		// Пересчет времени у точек, идущих после текущей.
		Сч = ИндексТекущейТочки + 1;
		Если Сч < КоличествоТочек Тогда
			
			ТочкаТекущая = Маршрут[ИндексТекущейТочки];
			
			Пока Сч < КоличествоТочек Цикл
				СледующаяТочка = Маршрут[Сч];
				Если НЕ СледующаяТочка.Отменена Тогда
					Если ПринятьФактическоеУбытиеИзТочкиЗаПлановое(ТочкаТекущая, ПересчитыватьПлановоеВремяПосещенияТочекМаршрута, ДопустимыйПериодРассогласованностиСФактическимиДанными) Тогда
						ПлановоеУбытиеИзТекущейТочки = ТочкаТекущая.УбытиеФакт;
					Иначе	
						ПлановоеУбытиеИзТекущейТочки = ТочкаТекущая.ПлановоеУбытие;
					КонецЕсли;
					
					//Если НЕ СледующаяТочка.Пройдена Тогда
						ЗаполнитьРастояниеДоПредыдущейТочки(ТочкаТекущая, СледующаяТочка, соотРасстояния);		
						ПлановоеПрибытиеВСледующуюТочку = ПлановоеУбытиеИзТекущейТочки + СледующаяТочка.ВремяОтПредыдущейТочки * КоэффициентПереводаВЧасы;
						
						Если УчитыватьРежимТрудаИОтдыхаСотрудников Тогда
							Если СтруктураПерерывовИПриращений.НовыеСутки Тогда
								Пока НачалоДня(НачалоТекущегоРабочегоДня) < НачалоДня(ПлановоеУбытиеИзТекущейТочки) Цикл
									НачалоТекущегоРабочегоДня = НачалоТекущегоРабочегоДня + 24*3600;
								КонецЦикла;
								СтруктураПерерывовИПриращений.ОтдыхПредыдущий = 0;
								СтруктураПерерывовИПриращений.НовыеСутки = Ложь;
							КонецЕсли;
							
							СтруктураПерерывовИПриращений.ФактПредыдущий  = ПлановоеУбытиеИзТекущейТочки - НачалоТекущегоРабочегоДня;
							СтруктураПерерывовИПриращений.ПлановоеВремяДоТочки = СледующаяТочка.ВремяОтПредыдущейТочки * КоэффициентПереводаВЧасы;
							НовоеПлановоеПрибытиеВСледующуюТочку = упЗаданиеНаПеревозкуВызовСервера.РассчитатьПриращениеВремениКТочке(СтруктураПерерывовИПриращений, ПлановоеПрибытиеВСледующуюТочку, НачалоТекущегоРабочегоДня, КоэффициентПереводаВЧасы);
							ВремяОтдыхаВПутиОтПредыдущейТочки 	 = НовоеПлановоеПрибытиеВСледующуюТочку - ПлановоеПрибытиеВСледующуюТочку;
							ПлановоеПрибытиеВСледующуюТочку 	 = НовоеПлановоеПрибытиеВСледующуюТочку;							
							СледующаяТочка.ВремяОтдыхаВПутиОтПредыдущейТочки = ВремяОтдыхаВПутиОтПредыдущейТочки / КоэффициентПереводаВЧасы;
						КонецЕсли;

						сткРезультат = СпланироватьЗадачиПоТочке(Работы, СледующаяТочка, ПлановоеПрибытиеВСледующуюТочку, КоэффициентПереводаВЧасы, ЧасовойПояс, РеквизитыАдресов);
						ЗаполнитьЗначенияСвойств(СледующаяТочка, сткРезультат);
					//КонецЕсли;
					ТочкаТекущая = СледующаяТочка;
				Иначе
					СброситьЗначенияТочки(СледующаяТочка);
				КонецЕсли;
				
				Сч = Сч + 1;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ПредыдущаяТочка(Маршрут, ИндексТекущейТочки)
	
	Результат = Неопределено;
			  
	ИндексПредыдущейТочки = ИндексТекущейТочки - 1;
		
	Пока ИндексПредыдущейТочки >= 0  Цикл
		
		Если НЕ Маршрут[ИндексПредыдущейТочки].Отменена Тогда
			Результат 	= Маршрут[ИндексПредыдущейТочки];	
			Прервать;
		КонецЕсли;
		
		ИндексПредыдущейТочки = ИндексПредыдущейТочки - 1;
	КонецЦикла;

	Возврат Результат;
	
КонецФункции

Функция ТекущаяТочка(Маршрут, ИндексТекущейТочки, КоличествоТочек)
	
	Результат = Неопределено;

	Если ИндексТекущейТочки < КоличествоТочек Тогда
	
		Пока ИндексТекущейТочки >= 0  Цикл
			
			ТекущаяТочкаЛк = Маршрут[ИндексТекущейТочки];
			
			Если ТекущаяТочкаЛк.Отменена Тогда
				СброситьЗначенияТочки(ТекущаяТочкаЛк);
			Иначе	
				Результат 	= ТекущаяТочкаЛк;	
				Прервать;
			КонецЕсли;
			
			ИндексТекущейТочки = ИндексТекущейТочки - 1;
		КонецЦикла;
	КонецЕсли;
	
	Если ИндексТекущейТочки = 0 
			И НЕ Результат = Неопределено Тогда
		Результат.РасстояниеОтПредыдущейТочки 	= 0;
		Результат.ВремяОтПредыдущейТочки 		= 0;
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

// Функция - Принять фактическое убытие из точки за плановое
//
// Параметры:
//  ТочкаМаршрута											 - СтрокаТаблицы, ДанныеФормыЭлементКоллекции - структура описывающая точку.
//  ПересчитыватьПлановоеВремяПосещенияТочекМаршрута		 - Булево	 - Устанавливает потребность в пересчете.
//  ДопустимыйПериодРассогласованностиСФактическимиДанными	 - Число	 - Количество минут, на которое допустимо опоздать или приехать раньше.
// 
// Возвращаемое значение:
//  Булево - Истина, есть необходимость в качестве планового взять фактическое убытие из предыдущей точки
//
Функция ПринятьФактическоеУбытиеИзТочкиЗаПлановое(ТочкаМаршрута, ПересчитыватьПлановоеВремяПосещенияТочекМаршрута, ДопустимыйПериодРассогласованностиСФактическимиДанными) Экспорт
	
	текРезультат = Ложь;
	
	Если ПересчитыватьПлановоеВремяПосещенияТочекМаршрута Тогда
		
		Если ТочкаМаршрута.Отменена Тогда
			
			текРезультат = Истина;	
			
		Иначе
			
			Если ЗначениеЗаполнено(ТочкаМаршрута.УбытиеФакт) Тогда
								
				ОтклонениеОтГрафикаМинут = Окр((ТочкаМаршрута.УбытиеФакт - ТочкаМаршрута.ПлановоеУбытие) / 60, 0);
				
				ОтклонениеОтГрафикаМинут = ?(ОтклонениеОтГрафикаМинут < 0, - ОтклонениеОтГрафикаМинут, ОтклонениеОтГрафикаМинут);
				
				Если ОтклонениеОтГрафикаМинут > ДопустимыйПериодРассогласованностиСФактическимиДанными Тогда
					текРезультат = Истина;	
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат текРезультат;
	
КонецФункции

// Выполним сброс значений точки.
//
// Параметры:
//  Точка - СправочникСсылка - Ссылка на элемент.
//
Процедура СброситьЗначенияТочки(Точка)
	
	Точка.РасстояниеОтПредыдущейТочки 	= 0;
	Точка.ВремяОтПредыдущейТочки 		= 0;
	Точка.ПлановоеПрибытие	= '00010101';
	Точка.ПлановоеУбытие		= '00010101';
	Точка.ПрибытиеФакт		= '00010101';
	Точка.УбытиеФакт			= '00010101';
	Точка.ПроездНеРассчитан 				= Ложь;
	
КонецПроцедуры

// Определяет расстояние между точками.
//
// Параметры:
//  Маршрут					 - ТаблицаЗначений	 - Таблица маршрута.
//  КоэффициентПереводаВЧасы		 - Число			 - Коэффициент.
//  ВызыватьМаршрутизацию		 - Булево			 - Вызывать.
//  ДополнительныеПараметры		 - Структура		 - параметры.
//  КоэффициентРасчетаВремениВПути	 - Число			 - коэффициент.
// 
// Возвращаемое значение:
//  Соответсвие - Значения.
//
Функция РассчитатьРасстоянияМеждуТочками(Маршрут, КоэффициентПереводаВЧасы = 3600, ВызыватьМаршрутизацию = Ложь, ДополнительныеПараметры = Неопределено, КоэффициентРасчетаВремениВПути = 0, Рейс = Неопределено) Экспорт
	
	Если Рейс = Неопределено Тогда
		ОграничениеМаршрутизатора = Неопределено;
	Иначе
		ОграничениеМаршрутизатора = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Рейс, "ОграничениеМаршрутизатора");
	КонецЕсли; 
	
	// Рассчитываются расстояния между точками цепочки маршрута.
	тзМаршрут = Новый ТаблицаЗначений;
	тзМаршрут.Колонки.Добавить("НомерСтроки", 	Новый ОписаниеТипов("Число"));
	тзМаршрут.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(36)));
	тзМаршрут.Колонки.Добавить("Адрес", 		Новый ОписаниеТипов("СправочникСсылка.упАдреса"));
	Сч = 1;
	Для каждого текСтрока Из Маршрут Цикл
		
		Если текСтрока.Отменена Тогда
			Продолжить
		Иначе
			НоваяСтрока = тзМаршрут.Добавить();
			НоваяСтрока.НомерСтроки   = Сч;
			НоваяСтрока.Идентификатор = Строка(текСтрока.Идентификатор);
			НоваяСтрока.Адрес 		  = текСтрока.Адрес;	 
		КонецЕсли;
				
		Сч = Сч + 1;
	КонецЦикла; 

	// Хранятся расстояния до предыдущих точек, ключ доступа идентификатор точки.
	соотРасстояния = упМаршрутизация.ПолучитьРасстояниеИВремяМеждуТочками(тзМаршрут, КоэффициентПереводаВЧасы, ВызыватьМаршрутизацию, ДополнительныеПараметры, ОграничениеМаршрутизатора);
	
	Если НЕ КоэффициентРасчетаВремениВПути = 0 Тогда
		
		Для каждого ЭлементСоответствия Из соотРасстояния Цикл
			сткДанные	= ЭлементСоответствия.Значение;
			сткДанные.Время			= КоэффициентРасчетаВремениВПути * сткДанные.Время;						
			сткДанные.ВремяПонедельник 	= КоэффициентРасчетаВремениВПути * сткДанные.ВремяПонедельник;
			сткДанные.ВремяВторник 		= КоэффициентРасчетаВремениВПути * сткДанные.ВремяВторник;
			сткДанные.ВремяСреда 		= КоэффициентРасчетаВремениВПути * сткДанные.ВремяСреда;
			сткДанные.ВремяЧетверг 		= КоэффициентРасчетаВремениВПути * сткДанные.ВремяЧетверг;
			сткДанные.ВремяПятница 		= КоэффициентРасчетаВремениВПути * сткДанные.ВремяПятница;
			сткДанные.ВремяСуббота 		= КоэффициентРасчетаВремениВПути * сткДанные.ВремяСуббота;
			сткДанные.ВремяВоскресенье 	= КоэффициентРасчетаВремениВПути * сткДанные.ВремяВоскресенье;
		КонецЦикла;
		
	КонецЕсли;

	Возврат соотРасстояния;
		
КонецФункции

// Процедура заполняем свойсва переданной точки на основании свойств предыдущей точки.
//
// Параметры:
//  ПредыдущаяТочка - СправочникСсылка - Ссылка на элемент.
//  Точка - СправочникСсылка - Ссылка на элемент.
//  соотРасстояния - Соответсвие - Значение.
//
Процедура ЗаполнитьРастояниеДоПредыдущейТочки(ПредыдущаяТочка, Точка, соотРасстояния) Экспорт
	
	сткДанные = соотРасстояния.Получить(ПредыдущаяТочка.Идентификатор);
	ДеньУбытия = ДеньНедели(ПредыдущаяТочка.ПлановоеУбытие);
	Если ДеньУбытия = 1 Тогда
		Точка.ВремяОтПредыдущейТочки = сткДанные.ВремяПонедельник;
	ИначеЕсли ДеньУбытия = 2 Тогда
		Точка.ВремяОтПредыдущейТочки = сткДанные.ВремяВторник;	
	ИначеЕсли ДеньУбытия = 3 Тогда
		Точка.ВремяОтПредыдущейТочки = сткДанные.ВремяСреда;	
	ИначеЕсли ДеньУбытия = 4 Тогда
		Точка.ВремяОтПредыдущейТочки = сткДанные.ВремяЧетверг;	
	ИначеЕсли ДеньУбытия = 5 Тогда
		Точка.ВремяОтПредыдущейТочки = сткДанные.ВремяПятница;	
	ИначеЕсли ДеньУбытия = 6 Тогда
		Точка.ВремяОтПредыдущейТочки = сткДанные.ВремяСуббота;	
	ИначеЕсли ДеньУбытия = 7 Тогда
		Точка.ВремяОтПредыдущейТочки = сткДанные.ВремяВоскресенье;	
	КонецЕсли; 
	Точка.РасстояниеОтПредыдущейТочки 	= сткДанные.Расстояние;
	Точка.ПроездНеРассчитан 			= сткДанные.ПроездНеРассчитан;
	
КонецПроцедуры

// Выполнить планирование задач по точке.
//
// Параметры:
//  Работы - ТаблицаЗначений - Таблица маршрута.
//  Точка - СправочникСсылка - Ссылка на элемент.
//  ВремяПрибытияВТочку - Число - время.
//  КоэффициентПереводаВЧасы - Число - Коэффициент.
//
// Возвращаемое значение:
//   Структура - Данные результата обработки.
//
Функция СпланироватьЗадачиПоТочке(Работы, Точка, ВремяПрибытияВТочку, КоэффициентПереводаВЧасы, ЧасовойПояс = Неопределено, РеквизитыАдресов = Неопределено, ВидПеревозки = Неопределено) 
	
	текВремяПрибытияВТочку = ВремяПрибытияВТочку;
    текВремяРаботВТочке	   = 0;
	текВремяОжиданияВТочке = 0;
	
	сткРезультат 	= Новый Структура("ПлановоеПрибытие, ПлановоеУбытие, ВремяОжиданияВТочке, ВремяРабот, НачалоРаботПлан, ВремяОжиданияВТочкеПослеРабот", текВремяПрибытияВТочку, '00010101', 0, 0,'00010101', 0);
	ИскомыеРаботы 	= Работы.НайтиСтроки(Новый Структура("Идентификатор", Точка.Идентификатор));
	
	тбзСтрокиПоПорядку = Новый ТаблицаЗначений;
	//тбзСтрокиПоПорядку.Колонки.Добавить("СтрокаНомер", 	Новый ОписаниеТипов("Число"));
	тбзСтрокиПоПорядку.Колонки.Добавить("СерединаВременногоОкна", Новый ОписаниеТипов("Дата"));
	тбзСтрокиПоПорядку.Колонки.Добавить("Строка");
	Для каждого СтрокаРабота Из ИскомыеРаботы  Цикл
		НоваяСтрокаРабота = тбзСтрокиПоПорядку.Добавить();
		//НоваяСтрокаРабота.СтрокаНомер 	= СтрокаРабота.СтрокаНомер;
		НоваяСтрокаРабота.СерединаВременногоОкна = СтрокаРабота.ВременноеОкноНачало + (СтрокаРабота.ВременноеОкноОкончание - СтрокаРабота.ВременноеОкноНачало) / 2;
		НоваяСтрокаРабота.Строка 		= СтрокаРабота;
	КонецЦикла;
	//тбзСтрокиПоПорядку.Сортировать("СтрокаНомер");
	тбзСтрокиПоПорядку.Сортировать("СерединаВременногоОкна");
	текНомер = 1;
	Для каждого СтрокаРабота Из тбзСтрокиПоПорядку Цикл
		текРабота = СтрокаРабота.Строка;
		воНачало = текРабота.ВременноеОкноНачало;
		воКонец  = ?(текРабота.ВременноеОкноОкончание = '00010101', '39991231', текРабота.ВременноеОкноОкончание);
		Если воНачало = '00010101' Или текВремяПрибытияВТочку >= воНачало Тогда
			текВремяОжидания = 0;
		Иначе	
			текВремяОжидания = воНачало - текВремяПрибытияВТочку;
		КонецЕсли;
		//Если текРабота.СтрокаНомер = 0 Тогда
		//	текРабота.СтрокаНомер 	= текНомер;
		//КонецЕсли;
		текРабота.ПлановоеВремяНачалаРабот = текВремяПрибытияВТочку + текВремяОжидания;
		текРабота.ВремяОжидания = текВремяОжидания/КоэффициентПереводаВЧасы;
		текВремяПрибытияВТочку 	= текРабота.ПлановоеВремяНачалаРабот + текРабота.ВремяРабот*КоэффициентПереводаВЧасы;
		текВремяОжиданияВТочке 	= текВремяОжиданияВТочке + текРабота.ВремяОжидания;
		текВремяРаботВТочке    	= текВремяРаботВТочке + текРабота.ВремяРабот;
		//текНомер = текРабота.СтрокаНомер + 1;
	КонецЦикла; 
	
	Если ЗначениеЗаполнено(Точка.Адрес)  И (Точка.ТипТочки = Перечисления.упТипыТочекМаршрута.ТочкаПоЗаданию Или Точка.ТипТочки = Перечисления.упТипыТочекМаршрута.КонтрольнаяТочка) Тогда
		текВремяПрохожденияТочки = ПолучитьВремяПрохожденияТочки(Точка.Адрес, ВидПеревозки);
		Если НЕ ЗначениеЗаполнено(текВремяПрохожденияТочки) Тогда
			текВремяПрохожденияТочки = 0;
		КонецЕсли;
	Иначе
		текВремяПрохожденияТочки = 0;
	КонецЕсли; 
	сткРезультат.НачалоРаботПлан		= сткРезультат.ПлановоеПрибытие;
	сткРезультат.ВремяОжиданияВТочке 	= текВремяОжиданияВТочке;
	сткРезультат.ВремяРабот				= текВремяРаботВТочке + текВремяПрохожденияТочки/КоэффициентПереводаВЧасы;
	ПлановоеУбытиеЛ = текВремяПрибытияВТочку + текВремяПрохожденияТочки;
	
	Если РеквизитыАдресов <> Неопределено Тогда
		РеквизитыАдреса = РеквизитыАдресов[Точка.Адрес];
	Иначе
		РеквизитыАдреса = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Точка.Адрес, "ИспользоватьВремяУбытияИзТочки, ВремяУбытияИзТочки, ДопустимоеОтклонениеУбытияИзТочки, ЧасовойПояс");
	КонецЕсли; 
	Если Ложь Тогда // Для контекстной подсказки
	    РеквизитыАдреса = Справочники.упАдреса.ПустаяСсылка();
	КонецЕсли;
	Если Истина
		И Не Точка.НеИспользоватьАвторасчетУбытияИзТочки
		И РеквизитыАдреса.ИспользоватьВремяУбытияИзТочки
		И Точка.ТипТочки <> Перечисления.упТипыТочекМаршрута.ТочкаЗавершения
	Тогда
		АдресВремяУбытияИзТочки = РеквизитыАдреса.ВремяУбытияИзТочки;
		Если ПолучитьФункциональнуюОпцию("упВедетсяРаботаВРазныхЧасовыхПоясах") Тогда
			АдресВремяУбытияИзТочки = упСервисныеФункции.ПеревестиВремяПриСменеЧасовогоПояса(АдресВремяУбытияИзТочки, РеквизитыАдреса.ЧасовойПояс, ЧасовойПояс);
		КонецЕсли; 
		ПлановоеУбытиеФикс = НачалоДня(ПлановоеУбытиеЛ) + (АдресВремяУбытияИзТочки - НачалоДня(АдресВремяУбытияИзТочки));
		Если ПлановоеУбытиеФикс + РеквизитыАдреса.ДопустимоеОтклонениеУбытияИзТочки * 3600 < ПлановоеУбытиеЛ Тогда
			ПлановоеУбытиеФикс = ПлановоеУбытиеФикс + 24*60*60;
		ИначеЕсли ПлановоеУбытиеФикс - РеквизитыАдреса.ДопустимоеОтклонениеУбытияИзТочки * 3600 < ПлановоеУбытиеЛ Тогда
			ПлановоеУбытиеФикс = ПлановоеУбытиеЛ;
		КонецЕсли; 
		сткРезультат.ВремяОжиданияВТочкеПослеРабот = (ПлановоеУбытиеФикс - ПлановоеУбытиеЛ) / КоэффициентПереводаВЧасы;
		ПлановоеУбытиеЛ = ПлановоеУбытиеФикс;
	КонецЕсли; 
	сткРезультат.ПлановоеУбытие = ПлановоеУбытиеЛ;
	Возврат сткРезультат;
	
КонецФункции

// Выполнить планирование задач по точке с конца.
//
// Параметры:
//  Работы - ТаблицаЗначений - Таблица маршрута.
//  Точка - СправочникСсылка - Ссылка на элемент.
//  ВремяУбытияИзТочки - Число - время.
//  КоэффициентПереводаВЧасы - Число - Коэффициент.
//
// Возвращаемое значение:
//   Структура - Данные результата обработки.
//
Функция СпланироватьЗадачиПоТочкеСКонца(Работы, Точка, ВремяУбытияИзТочки, КоэффициентПереводаВЧасы, ВидПеревозки = Неопределено) 
	
	текВремяУбытияИзТочки = ВремяУбытияИзТочки;
	текВремяРаботВТочке	   = 0;
	текВремяОжиданияВТочке = 0;
	
	сткРезультат = Новый Структура("ПлановоеПрибытие, ПлановоеУбытие, ВремяОжиданияВТочке, ВремяРабот, НачалоРаботПлан", '00010101', ВремяУбытияИзТочки, 0, 0,'00010101');
	ИскомыеРаботы = Работы.НайтиСтроки(Новый Структура("Идентификатор", Точка.Идентификатор));
	КоличествоРабот = ИскомыеРаботы.Количество();
	Сч = КоличествоРабот - 1;
	Пока Сч >= 0 Цикл
		текРабота = ИскомыеРаботы[Сч];
		воНачало = текРабота.ВременноеОкноНачало;
		воКонец  = ?(текРабота.ВременноеОкноОкончание = '00010101', '39991231', текРабота.ВременноеОкноОкончание);
		ВозможноеПрибытие = текВремяУбытияИзТочки - текРабота.ВремяРабот*КоэффициентПереводаВЧасы;
		текРабота.ПлановоеВремяНачалаРабот = ВозможноеПрибытие;
		текРабота.ВремяОжидания = 0;
		текВремяУбытияИзТочки = текРабота.ПлановоеВремяНачалаРабот; 
		текВремяОжиданияВТочке = текВремяОжиданияВТочке + текРабота.ВремяОжидания;
		текВремяРаботВТочке    = текВремяРаботВТочке + текРабота.ВремяРабот;
		Сч = Сч - 1;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(Точка.Адрес) И (Точка.ТипТочки = Перечисления.упТипыТочекМаршрута.ТочкаПоЗаданию Или Точка.ТипТочки = Перечисления.упТипыТочекМаршрута.КонтрольнаяТочка) Тогда
		текВремяПрохожденияТочки = ПолучитьВремяПрохожденияТочки(Точка.Адрес, ВидПеревозки);
	Иначе
		текВремяПрохожденияТочки = 0;
	КонецЕсли; 
	сткРезультат.ПлановоеПрибытие	    = текВремяУбытияИзТочки - текВремяПрохожденияТочки;
	сткРезультат.НачалоРаботПлан		= сткРезультат.ПлановоеПрибытие;
	сткРезультат.ВремяОжиданияВТочке    = текВремяОжиданияВТочке;
	сткРезультат.ВремяРабот			    = текВремяРаботВТочке + текВремяПрохожденияТочки/КоэффициентПереводаВЧасы;
	Возврат сткРезультат;
	
КонецФункции

// Заполняет набор свойств для переданных товаров.
//
// Параметры:
//  мсвТоварныйСостав - Массив - Массив ссылок.
//  ПолучитьКлассОпасности - Булево - Флаг выполнения.
//  ПолучитьТемпературныйРежим - Булево - Флаг выполнения.
//
// Возвращаемое значение:
//   Структура - Данные результата обработки.
//
Функция ПолучитьХарактеристикиПоТоварам(мсвТоварныйСостав, ПолучитьКлассОпасности = Ложь, ПолучитьТемпературныйРежим = Ложь) Экспорт

	сткРезультат	 = Новый Структура("Масса, Объем, КлассОпасности, ТемпературныйРежим", 0, 0, 
												Неопределено, 
												Неопределено);
												
	ТоварныйСостав = Новый ТаблицаЗначений;
	ТоварныйСостав.Колонки.Добавить("Номенклатура", 		Новый ОписаниеТипов("СправочникСсылка.упНоменклатура"));
	ТоварныйСостав.Колонки.Добавить("УпаковкаНоменклатуры", Новый ОписаниеТипов("СправочникСсылка.упУпаковкиНоменклатуры"));
	ТоварныйСостав.Колонки.Добавить("Количество", 			Новый ОписаниеТипов("Число"));
	
	мсвНоменклатуры = Новый Массив;
	                               	
	Для каждого текСтрока Из мсвТоварныйСостав Цикл
		текНоваяСтрока	= ТоварныйСостав.Добавить();
		ЗаполнитьЗначенияСвойств(текНоваяСтрока, текСтрока);
		мсвНоменклатуры.Добавить(текСтрока.Номенклатура);
	КонецЦикла;
												
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	тбТовары.Номенклатура,
	               |	тбТовары.УпаковкаНоменклатуры,
	               |	тбТовары.Количество
	               |ПОМЕСТИТЬ втТовары
	               |ИЗ
	               |	&тбТовары КАК тбТовары
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	СУММА(ЕСТЬNULL(упУпаковкиНоменклатуры.Масса, упНоменклатура.Масса) * втТовары.Количество) КАК Масса,
	               |	СУММА(ЕСТЬNULL(упУпаковкиНоменклатуры.Объем, упНоменклатура.Объем) * втТовары.Количество) КАК Объем
	               |ИЗ
	               |	втТовары КАК втТовары
	               |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.упНоменклатура КАК упНоменклатура
	               |		ПО втТовары.Номенклатура = упНоменклатура.Ссылка
	               |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.упУпаковкиНоменклатуры КАК упУпаковкиНоменклатуры
	               |		ПО втТовары.УпаковкаНоменклатуры = упУпаковкиНоменклатуры.Ссылка";
	Запрос.УстановитьПараметр("тбТовары", ТоварныйСостав);
	текВыборка = Запрос.Выполнить().Выбрать();
	
	Если текВыборка.Следующий() Тогда
		ЗаполнитьЗначенияСвойств(сткРезультат, текВыборка);
	КонецЕсли;
	
	Если ПолучитьКлассОпасности И ПолучитьФункциональнуюОпцию("упУчитыватьКлассыОпасностиГрузов") Тогда
	 
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ
		               |	упНоменклатура.КлассОпасности
		               |ИЗ
		               |	Справочник.упНоменклатура КАК упНоменклатура
		               |ГДЕ
		               |	упНоменклатура.Ссылка В(&Ссылка)
		               |	И упНоменклатура.КлассОпасности <> ЗНАЧЕНИЕ(Справочник.упКлассыОпасности.ПустаяСсылка)
		               |
		               |УПОРЯДОЧИТЬ ПО
		               |	упНоменклатура.КлассОпасности.Класс";
		Запрос.УстановитьПараметр("Ссылка", мсвНоменклатуры);
		
		текВыборка = Запрос.Выполнить().Выбрать();
		Если текВыборка.Следующий() Тогда 
			сткРезультат.КлассОпасности = текВыборка.КлассОпасности;
		КонецЕсли;
	КонецЕсли;
	
	Если ПолучитьТемпературныйРежим И ПолучитьФункциональнуюОпцию("упКонтролироватьТемпературныеРежимы") Тогда
	    			
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ
		|	МАКСИМУМ(упНоменклатура.ТемпературныйРежим.ТемператураОт) КАК ТемпературныйРежимТемператураОт,
		|	МИНИМУМ(упНоменклатура.ТемпературныйРежим.ТемператураДо) КАК ТемпературныйРежимТемператураДо
		|ПОМЕСТИТЬ втДопустимыйДиапазон
		|ИЗ
		|	Справочник.упНоменклатура КАК упНоменклатура
		|ГДЕ
		|	упНоменклатура.Ссылка В(&Ссылка)
		|	И упНоменклатура.ТемпературныйРежим <> ЗНАЧЕНИЕ(Справочник.упТемпературныережимы.ПустаяСсылка)
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	упТемпературныеРежимы.Ссылка,
		|	упТемпературныеРежимы.ТемператураДо - упТемпературныеРежимы.ТемператураОт КАК Порядок
		|ИЗ
		|	Справочник.упТемпературныеРежимы КАК упТемпературныеРежимы
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ втДопустимыйДиапазон КАК втДопустимыйДиапазон
		|		ПО упТемпературныеРежимы.ТемператураОт >= втДопустимыйДиапазон.ТемпературныйРежимТемператураОт
		|			И упТемпературныеРежимы.ТемператураДо <= втДопустимыйДиапазон.ТемпературныйРежимТемператураДо
		|ГДЕ
		|	НЕ упТемпературныеРежимы.ПометкаУдаления
		|
		|УПОРЯДОЧИТЬ ПО
		|	Порядок УБЫВ";
		Запрос.УстановитьПараметр("Ссылка", мсвНоменклатуры);
		
		текВыборка = Запрос.Выполнить().Выбрать();
		Если текВыборка.Следующий() Тогда 
			сткРезультат.ТемпературныйРежим = текВыборка.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат сткРезультат;

КонецФункции // ()

// Возвращает таблицу документов "упЗаданиеНаПеревозкуГруза".
//
// Параметры:
//  мсвЗаданияНаПеревозкуГруза - Массив - Массив ссылок.
//
// Возвращаемое значение:
//  ТаблицаЗначений - Табличные данные.
//
Функция ПолучитьЗаявкиПоЗаданиям(мсвЗаданияНаПеревозкуГруза) Экспорт
	
	Возврат  упЗаданиеНаПеревозку.ПолучитьЗаявкиПоЗаданиям(мсвЗаданияНаПеревозкуГруза).ВыгрузитьКолонку("Заявка");
		
КонецФункции // ПолучитьЗаявкиПоЗаданиям()

// Возвращает тару грузового места
//
// Параметры:
//  Задание		 - ДокументСсылка.упЗаданиеНаПеревозкуГруза	 - задание.
//  ГрузовоеМесто	 - СправочникСсылка.упГрузовыеМеста		 - грузовое место.
// 
// Возвращаемое значение:
//  Тара - СправочникСсылка.упГрузовыеМеста
//
Функция ПолучитьТаруГрузовогоМеста(Задание, ГрузовоеМесто) Экспорт
	
	Тара = Справочники.упГрузовыеМеста.ПустаяСсылка();
	Если ПолучитьФункциональнуюОпцию("упВедетсяУчетТары") И ЗначениеЗаполнено(ГрузовоеМесто) Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	упЗаданияКПланированию.Тара
		|ИЗ
		|	РегистрНакопления.упЗаданияКПланированию КАК упЗаданияКПланированию
		|ГДЕ
		|	упЗаданияКПланированию.Регистратор = &Регистратор
		|	И упЗаданияКПланированию.Задание = &Задание
		|	И упЗаданияКПланированию.ГрузовоеМесто = &ГрузовоеМесто
		|	И НЕ упЗаданияКПланированию.Тара = ЗНАЧЕНИЕ(Справочник.упГрузовыеМеста.ПустаяСсылка)";
		Запрос.УстановитьПараметр("Регистратор", Задание);
		Запрос.УстановитьПараметр("Задание", Задание);
		Запрос.УстановитьПараметр("ГрузовоеМесто", ГрузовоеМесто);
		РезультатЗапроса = Запрос.Выполнить();
		Если Не РезультатЗапроса.Пустой() Тогда
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Тара = Выборка.Тара;
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат Тара;
	
КонецФункции

// Функция - Возвращает массив зависимых типы грузов.
//
// Параметры:
//  ВидПеревозки	 - СправочникСсылка.упВидыПеревозок	 - вид перевозки.
//  ТипГруза		 - СправочникСсылка.упТипыГрузов	 - тип груза.
// 
// Возвращаемое значение:
//  Массив (СправочникСсылка.упТипыГрузов)  - массив типы грузов.
//
Функция ЗависимыеТипыГрузовПоЗаданию(ЗаданиеНаПеревозкуГруза, ТипГруза) Экспорт
	
	мсвРезультат = Новый Массив;
	
	Если Истина
		И ЗначениеЗаполнено(ЗаданиеНаПеревозкуГруза)
		И ЗначениеЗаполнено(ТипГруза)
	Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"
		|ВЫБРАТЬ
		|	ПравилаСвязи.ЗависимыйТипГруза КАК ЗависимыйТипГруза
		|ИЗ
		|	Справочник.упПравилаСвязиТиповГрузов.Связи КАК ПравилаСвязи
		|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.упВидыПеревозок КАК ВидыПеревозок
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.упЗаданиеНаПеревозкуГруза КАК ЗаданиеНаПеревозкуГруза
		|		ПО ЗаданиеНаПеревозкуГруза.ВидПеревозки = ВидыПеревозок.Ссылка
		|	ПО ВидыПеревозок.ПравилоСвязиТиповГрузовВРейсе = ПравилаСвязи.Ссылка
		|ГДЕ ИСТИНА
		|	И ПравилаСвязи.ОсновнойТипГруза = &ТипГруза
		|	И ЗаданиеНаПеревозкуГруза.Ссылка = &ЗаданиеНаПеревозкуГруза
		|";

		Запрос.УстановитьПараметр("ЗаданиеНаПеревозкуГруза", ЗаданиеНаПеревозкуГруза);
		Запрос.УстановитьПараметр("ТипГруза", ТипГруза);
		Выборка	= Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			мсвРезультат.Добавить(Выборка.ЗависимыйТипГруза);		
		КонецЦикла; 
	КонецЕсли;
	
	Возврат мсвРезультат;
		
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыФункции

// Возвращает время прохождения точки маршрута
//
// Параметры:
//  Адрес		
//  ВидПеревозки 
// 
// Возвращаемое значение:
//   ВремяПрохожденияТочки 
//
Функция ПолучитьВремяПрохожденияТочки(Адрес, ВидПеревозки)
	
	ВремяПрохожденияТочки = Неопределено;
	Если ЗначениеЗаполнено(ВидПеревозки) И ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ВидПеревозки, "ИспользоватьСтатистикуПриОпределенииВремениПрохожденияТочки") Тогда		
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	упСтатистика.СреднееВремя
		|ИЗ
		|	РегистрСведений.упСтатистикаНахожденияВТочкахПартнеров КАК упСтатистика
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ (ВЫБРАТЬ
		|			упАдреса.Ссылка КАК Адрес
		|		ИЗ
		|			Справочник.упВидыПеревозок.ВидыАдресовДляСтатистики КАК ВидыАдресов
		|				ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.упАдреса КАК упАдреса
		|				ПО (ВидыАдресов.Ссылка = &ВидПеревозки)
		|					И (упАдреса.Ссылка = &Адрес)
		|					И ВидыАдресов.ВидАдреса = упАдреса.ВидАдреса) КАК ВложенныйЗапрос
		|		ПО упСтатистика.Адрес = ВложенныйЗапрос.Адрес";
		Запрос.УстановитьПараметр("Адрес", Адрес);
		Запрос.УстановитьПараметр("ВидПеревозки", ВидПеревозки);
		РезультатЗапроса = Запрос.Выполнить();
		Если Не РезультатЗапроса.Пустой() Тогда
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			ВремяПрохожденияТочки = Выборка.СреднееВремя;
		КонецЕсли; 
	КонецЕсли;
	
	Если ВремяПрохожденияТочки = Неопределено Тогда
		ВремяПрохожденияТочки  = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Адрес, Новый Структура("ВремяПрохожденияТочки", "ВидАдреса.ВремяПрохожденияТочки")).ВремяПрохожденияТочки;
	КонецЕсли;
	
	Возврат ВремяПрохожденияТочки;

КонецФункции

#Область ДляСоставленияДопустимогоРасписания

// Возвращает возможность использования расписания без прерывания.
//
// Параметры:
//  тбзРасписание - ТаблицаЗначений - Табличные данные.
//
// Возвращаемое значение:
//  Булево - Результат проверки.
//
Функция РасписаниеДопустимоБезПрерываний(тбзРасписание) Экспорт
	
	текРезультат = Истина;
	N = тбзРасписание.Количество();
	Для k = 1 По N Цикл
		Для l = k По N Цикл
			
			d_k = тбзРасписание.Получить(k-1).МоментПоступления; 	// Момент поступления k-го требования.
			D_l = тбзРасписание.Получить(l-1).ДирективныйСрок; 		// Директивный срок l-го требования.
			
			Сумма = 0; // Сумма времени обслуживания требований с k-го по l.
			
			Для i = k По l Цикл
				Сумма = Сумма + тбзРасписание.Получить(i-1).ВремяНаОбслуживание;
			КонецЦикла;		
			
			Если Сумма > D_l - d_k Тогда
				текРезультат = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если НЕ текРезультат Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат текРезультат;
	
КонецФункции

// Возращает массив допустимых расписаний.
//
// Параметры:
//  тбзРасписание - ТаблицаЗначений - Табличные данные.
//  тбзРасписаниеРаботыПрибора - ТаблицаЗначений - Табличные данные.
//
// Возвращаемое значение:
//  Массив - Данные обработки.
//
Функция ПолучитьДопустимоеРасписание(тбзРасписание, тбзРасписаниеРаботыПрибора) Экспорт
	
	текМаксимальнаяТочка = 99999999999999999;
	
	мсвРасписание = Новый Массив;
		
	Если тбзРасписание.Количество()=0 Тогда
		Возврат тбзРасписание;
	КонецЕсли;
	
	тбзРасписание.Сортировать("МоментПоступления");
	
	мсвГруппыТребований  = Новый Массив;
	
	// Формируется упорядоченное множество различных моментов поступления.
	мсвМоментовПоступления = Новый Массив;
	текКоличество = тбзРасписание.Количество()-1;
	Для каждого текСтрока Из тбзРасписание Цикл
		текИндекс = мсвМоментовПоступления.Найти(текСтрока.МоментПоступления);
		Если текИндекс = Неопределено Тогда
			мсвМоментовПоступления.Добавить(текСтрока.МоментПоступления);
			мсвТребований	= Новый Массив;
			мсвТребований.Добавить(текСтрока); 					// Требование относящееся к моменту.
			мсвГруппыТребований.Добавить(мсвТребований); 		// Требований может быть несколько.
		Иначе
			мсвГруппыТребований[текИндекс].Добавить(текСтрока); // Требование добавляется в соответствующую группу.
		КонецЕсли;
	КонецЦикла;
	
	// элемент ограничивающий сверху.
	мсвМоментовПоступления.Добавить(текМаксимальнаяТочка);
	мсвТребований	= Новый Массив;
	мсвГруппыТребований.Добавить(мсвТребований); 
	
	тбзРасписаниеРаботыСистемы = Неопределено;
	 	
	// Инициализация параметров.
	u = 0;
	r = мсвМоментовПоступления[u];
	
	N_0 = Новый Массив; 
	Для каждого текЭлемент Из мсвГруппыТребований[u] Цикл
		N_0.Добавить(текЭлемент);	
	КонецЦикла;
	
	u = u + 1;
	d_u	= мсвМоментовПоступления[u];
	текКоличествоМоментов = мсвМоментовПоступления.Количество();
	
	Пока N_0.Количество() > 0 Цикл
		
		сткТребование = ПолучитьТребованиеСМинимальнымДирективнымСроком(N_0);
		j	= сткТребование.Индекс;
		ЗаполнитьВремяОжиданияСогласноРасписанию(r, тбзРасписаниеРаботыПрибора, сткТребование.Требование);
		t_j = сткТребование.Требование.ВремяНаОбслуживание + сткТребование.Требование.ВремяНаОжидание;
		
		Если (r + t_j > d_u) Тогда
			t_j	= t_j - (d_u - r);
			Для каждого текЭлемент Из мсвГруппыТребований[u] Цикл
				N_0.Добавить(текЭлемент);	
			КонецЦикла;
            r	= d_u;
			
			u	= u + 1;
			Если u < текКоличествоМоментов  Тогда
				d_u	= мсвМоментовПоступления[u];
			КонецЕсли;
		ИначеЕсли (r + t_j < d_u) И (N_0.Количество() = 1) ИЛИ r + t_j = d_u Тогда
			
			мсвРасписание.Добавить(сткТребование.Требование);
			
			// Исключить из N_0 требование j.
			N_0.Удалить(j);
			Для каждого текЭлемент Из мсвГруппыТребований[u] Цикл
				N_0.Добавить(текЭлемент);	
			КонецЦикла;
			r	= d_u;
			
			// Добавить все требования.
			u	= u + 1;
			Если u < текКоличествоМоментов  Тогда
				d_u	= мсвМоментовПоступления[u];
			КонецЕсли;	
		ИначеЕсли (r + t_j < d_u) И (N_0.Количество() > 1)  Тогда 
			мсвРасписание.Добавить(сткТребование.Требование);
			// Исключить из N_0 требование j.
			N_0.Удалить(j);
			r = r + t_j;
		КонецЕсли;
		
		
	КонецЦикла;
	
	Возврат мсвРасписание;

КонецФункции

// Увеличивает время выполнения задания на время перерывов в работе системы.
//
// Параметры:
//  ВремяНачала - Дата - Период.
//  тбзРасписаниеРаботыПрибора - ТаблицаЗначений - Табличные данные.
//  СтрокаРаботы - Структура - Работы.
//
Процедура ЗаполнитьВремяОжиданияСогласноРасписанию(ВремяНачала, тбзРасписаниеРаботыПрибора, СтрокаРаботы)
	
	текВремяНаОжидание 		 = 0;
	текВремяНаОжиданиеНачало = 0;
	ЕстьОжиданиеНаНачало	 = Ложь;
	
	Если НЕ тбзРасписаниеРаботыПрибора = Неопределено Тогда
		
		текОстатокВремени 	= СтрокаРаботы.ВремяНаОбслуживание;
		текВремяНачала		= ВремяНачала;
		
		Для каждого текСтрока Из тбзРасписаниеРаботыПрибора Цикл
			
			Если текОстатокВремени = 0 Тогда
				Прервать;                          				
			КонецЕсли;
			
			Если текВремяНачала <=  текСтрока.Начало Тогда
				
				Если НЕ ЕстьОжиданиеНаНачало Тогда
					ЕстьОжиданиеНаНачало = Истина;
					текВремяНаОжиданиеНачало	= текСтрока.Начало - текВремяНачала;
				Иначе
					текВремяНаОжидание	= текВремяНаОжидание + (текСтрока.Начало - текВремяНачала);
				КонецЕсли;
				текВремяНаИнтервале	= Мин(текОстатокВремени, текСтрока.Окончание - текСтрока.Начало);
				текОстатокВремени 	= текОстатокВремени - текВремяНаИнтервале;
				текВремяНачала		= текВремяНачала + текВремяНаИнтервале;
			Иначе
				Если текВремяНачала < текСтрока.Окончание Тогда
					текВремяНаИнтервале	= Мин(текОстатокВремени, текСтрока.Окончание - текВремяНачала);
					текОстатокВремени 	= текОстатокВремени - текВремяНаИнтервале;
					текВремяНачала		= текВремяНачала + текВремяНаИнтервале;
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
	
	КонецЕсли;
	
	СтрокаРаботы.ВремяНаОжидание 		= текВремяНаОжидание;
	СтрокаРаботы.ВремяНаОжиданиеНачало 	= текВремяНаОжиданиеНачало;
		
КонецПроцедуры // ПолучитьВремяНаобслуживаниеСогласноРасписанию()

// Корректирует время поступления задания в соответствии с расписанием прибора
//
// Параметры:
//  ВремяНачала - Дата - Период.
//  тбзРасписание - ТаблицаЗначений - Табличные данные.
//
// Возвращаемое значение:
//  Дата - Данные обработки.
//
Функция СкорректироватьМоментПоступления(ВремяНачала, тбзРасписание) Экспорт
	
	текРезультат = ВремяНачала;
	
	Если НЕ тбзРасписание = Неопределено Тогда
		
		// Обход временных периодов.
		Для каждого текСтрока Из тбзРасписание Цикл
			
			Если текРезультат < текСтрока.Окончание Тогда
				
				Если текРезультат < текСтрока.Начало Тогда
				    текРезультат = текСтрока.Начало
				КонецЕсли;
				Прервать;
			КонецЕсли;
		КонецЦикла;		
	КонецЕсли;
	
	Возврат текРезультат;
	
КонецФункции // ПолучитьВремяНаобслуживаниеСогласноРасписанию()

// Получить требование с минимальным директивным сроком.
//
// Параметры:
//  мсвТребований - Массив - Требования.
//
// Возвращаемое значение:
//  Структура - Данные обработки.
//
Функция ПолучитьТребованиеСМинимальнымДирективнымСроком(мсвТребований)
	
	сткРезультат = Новый Структура("Требование, Индекс");
	ТребованиеМинДирективнымСроком  = мсвТребований[0];
	ИндексТребования				= 0;
			
	текКоличество = мсвТребований.Количество();
	
	Если текКоличество > 1 Тогда
		Для текИндекс = 1 По текКоличество-1 Цикл
			Если мсвТребований[текИндекс].ДирективныйСрок < ТребованиеМинДирективнымСроком.ДирективныйСрок Тогда
				ТребованиеМинДирективнымСроком	= мсвТребований[текИндекс];
				ИндексТребования				= текИндекс;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	сткРезультат.Требование	= ТребованиеМинДирективнымСроком;
	сткРезультат.Индекс		= ИндексТребования;

	Возврат сткРезультат;
	
КонецФункции

// Перевод даты в число секунд.
//
// Параметры:
//  текДата - Дата - Период.
//
// Возвращаемое значение:
//  Число - Данные обработки.
//
Функция ДатаВЧисло(текДата) Экспорт
	
	текРезультат = текДата - '00010101';
	
	Возврат текРезультат
	
КонецФункции

// Перевод числа секунд в дату.
//
// Параметры:
//  текЧисло - Число - Количество.
//
// Возвращаемое значение:
//  Дата - Данные обработки.
//
Функция ЧислоВДату(текЧисло) Экспорт

	Результат  = '00010101' + текЧисло;
			
	Возврат Результат;	

КонецФункции // ЧислоВДату()

// Функция - Вид груза.
//
// Параметры:
//	ГрузовоеМесто	 - Справочник.упГрузовыеМеста - грузовое место.
// 
// Возвращаемое значение:
//  Перечисление.упВидыГрузов - вид груза.
//
Функция ВидГруза(ГрузовоеМесто) Экспорт
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ГрузовоеМесто, "ТипГруза.ВидГруза");	
КонецФункции

#КонецОбласти

#Область РежимыТрудаИОтдыха

// Функция возвращает временную таблицу начала перерывов и их длительности согласно правилу режимов труда
Функция ПолучитьТаблицуПерерывовИПриращений(Правило, КоэффициентПереводаИзЧасов = 3600, КоэффициентПереводаИзМинут = 60) Экспорт
	
	Если Ложь Тогда // Для контекстной подсказки
	    Правило = Справочники.упПравилаРежимаТрудаИОтдыхаСотрудников.ПустаяСсылка();
	КонецЕсли;
	ТаблицаРезультат = Новый ТаблицаЗначений;
	ТаблицаРезультат.Колонки.Добавить("ВремяНачалаПерерыва");
	ТаблицаРезультат.Колонки.Добавить("Приращение");
	ТаблицаРезультат.Колонки.Добавить("НовыеСутки", Новый ОписаниеТипов("Булево"));
	ТаблицаРезультат.Колонки.Добавить("Обед", Новый ОписаниеТипов("Булево"));
	
// Проверим заполненность данных для проведения рассчета	
	Если НЕ ПроверитьОбязательныеПараметрыПравилРежимовТруда(Правило) Тогда
		Возврат ТаблицаРезультат;
	КонецЕсли;
	
	СтопПересчет = Ложь;
	
	ПродолжительностьРабочегоВремениДень = Правило.ПродолжительностьРабочегоВремениДеньЧ * КоэффициентПереводаИзЧасов;
	НесколькоВодителей = Правило.НесколькоВодителей;
	
	ПерерывОбедОтдыхКоличество = Правило.ПерерывОбедОтдыхКоличество;
	
	МассивОбедовОтдыхов = Новый Массив;
	Для нСчетчик = 1 По ПерерывОбедОтдыхКоличество Цикл
	// Пока не понятно что делать если время перерыва наступило до окончания рабочего дня, но сам перерыв превысит окончание рабочего дня
	// Например время наступления перерыва 17:40, длительность 1 час, окончание рабочего дня в 18:00
	
		СледПерерывОбедОтдых = Правило.ПерерывОбедОтдыхПериодичностьЧ * нСчетчик * КоэффициентПереводаИзЧасов;
		Если СледПерерывОбедОтдых >= ПродолжительностьРабочегоВремениДень Тогда
			Прервать;
		КонецЕсли;
		
	// Каждый последующий перерыв на обед/отдых наступает через равный промежуток (ПерерывОбедОтдыхПериодичностьЧ) с начала работы/смены	
		НоваяСтрока = ТаблицаРезультат.Добавить();	
		НоваяСтрока.ВремяНачалаПерерыва = СледПерерывОбедОтдых;
		НоваяСтрока.Приращение 			= Правило.ПерерывОбедОтдыхПродолжительностьМ * КоэффициентПереводаИзМинут;
		НоваяСтрока.Обед				= Истина;
		
		МассивОбедовОтдыхов.Добавить(СледПерерывОбедОтдых);
	КонецЦикла;
	
// Первый спец.перерыв	
	СледСпецПерерыв = Правило.СпециальныйПерерывПервыйПериодичностьЧ * КоэффициентПереводаИзЧасов;
	Если СледСпецПерерыв >= ПродолжительностьРабочегоВремениДень Тогда
		// Если первый спец.перерыв наступает после окончания рабочего дня, то последующие спец.перерывы бессмысленны	
		СтопПересчет = Истина;
	ИначеЕсли СледСпецПерерыв = 0 Тогда
		СтопПересчет = Истина;
	КонецЕсли;

	Если НЕ СтопПересчет Тогда		
		
		МассивУдалитьСтроки = Новый Массив;
		// !// Если перерыв попадает на обед, то расчитаем след. перерыв от начала обеда.
		
		// Если первый спец. перерыв попадает на обед, то он поглащается обедом и не учитывается
		Для Каждого ЗначОбед из МассивОбедовОтдыхов Цикл
			Если СледСпецПерерыв >= ЗначОбед Тогда
				//!СледСпецПерерыв = ЗначОбед + Правила.СпециальныйПерерывПервыйПериодичностьЧ * КоэффициентПереводаИзЧасов;
				СледСпецПерерыв = ЗначОбед + Правило.ПерерывОбедОтдыхПродолжительностьМ * КоэффициентПереводаИзМинут;
				МассивУдалитьСтроки.Добавить(ЗначОбед);
			КонецЕсли;
		КонецЦикла;
		
		НоваяСтрока = ТаблицаРезультат.Добавить();	
		НоваяСтрока.ВремяНачалаПерерыва = СледСпецПерерыв;
		НоваяСтрока.Приращение 			= Правило.СпециальныйПерерывПервыйПродолжительностьМ * КоэффициентПереводаИзМинут;
		
		// Обеды относительно которых уже произошел пересчет, убираем из расчета
		Для Каждого ЗначОбед ИЗ МассивУдалитьСтроки Цикл
			нИндекс = МассивОбедовОтдыхов.Найти(ЗначОбед);
			МассивОбедовОтдыхов.Удалить(нИндекс);
		КонецЦикла;
		
	// Каждый последующий спец. перерыв наступает через равный промежуток с предыдущего перерыва
		Пока Истина Цикл
			
			Если НЕ ЗначениеЗаполнено(Правило.СпециальныйПерерывПоследующиеПериодичностьЧ) Тогда
				Прервать;
		    КонецЕсли;

		// Последующие спец.перерыв
			СледСпецПерерыв = СледСпецПерерыв + Правило.СпециальныйПерерывПоследующиеПериодичностьЧ * КоэффициентПереводаИзЧасов;
			Если СледСпецПерерыв >= ПродолжительностьРабочегоВремениДень Тогда
				Прервать;
			КонецЕсли;
			
			МассивУдалитьСтроки = Новый Массив;
			// если перерыв попадает на обед, то расчитаем след. перерыв от начала обеда				
			Для Каждого ЗначОбед из МассивОбедовОтдыхов Цикл
				Если СледСпецПерерыв >= ЗначОбед Тогда
					СледСпецПерерыв = ЗначОбед + Правило.СпециальныйПерерывПоследующиеПериодичностьЧ * КоэффициентПереводаИзЧасов;
					МассивУдалитьСтроки.Добавить(ЗначОбед);
				КонецЕсли;
			КонецЦикла;
			
			// Обеды относительно которых уже произошел пересчет, убираем из расчета
			Для Каждого ЗначОбед ИЗ МассивУдалитьСтроки Цикл
				нИндекс = МассивОбедовОтдыхов.Найти(ЗначОбед);
				МассивОбедовОтдыхов.Удалить(нИндекс);
			КонецЦикла;
			
			НоваяСтрока = ТаблицаРезультат.Добавить();	
			НоваяСтрока.ВремяНачалаПерерыва = СледСпецПерерыв;
			НоваяСтрока.Приращение 			= Правило.СпециальныйПерерывПоследующиеПродолжительностьМ * КоэффициентПереводаИзМинут;
		КонецЦикла;
	КонецЕсли;	
	
// упорядочим таблицу по времени перерывов
	ТаблицаРезультат.Сортировать("ВремяНачалаПерерыва");
	ВремТаблица = ТаблицаРезультат.Скопировать();
	нКолвоСтрок = ВремТаблица.Количество();
	
// Прирастим время начала каждого следующего перерыва с учетом времени отдыха в предыдущих перерывах
	нСчетчик = 1;
	Для Каждого Строка из ВремТаблица Цикл
		Приращение = Строка.Приращение;
		
		Для нНомерСтроки = нСчетчик + 1 По нКолвоСтрок Цикл
			СтрокаТаблицаРезультат = ТаблицаРезультат[нНомерСтроки - 1];
			// Сецперерыв не сдвигает обед
			Если НЕ Строка.Обед И СтрокаТаблицаРезультат.Обед Тогда
	        	Продолжить;
			КонецЕсли;
			СтрокаТаблицаРезультат.ВремяНачалаПерерыва = СтрокаТаблицаРезультат.ВремяНачалаПерерыва + Приращение;
		КонецЦикла;
		
		нСчетчик = нСчетчик + 1;
	КонецЦикла;
	
// Удалим позиции, выходящие за рамки рабочего времени, оказавшиеся там после приращения перерывов		
	МассивУдалитьСтроки = Новый Массив;
	Для Каждого СтрокаРезультат Из ТаблицаРезультат Цикл
		Если СтрокаРезультат.ВремяНачалаПерерыва >= ПродолжительностьРабочегоВремениДень Тогда
			МассивУдалитьСтроки.Добавить(СтрокаРезультат);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЗначРезультат ИЗ МассивУдалитьСтроки Цикл
		ТаблицаРезультат.Удалить(ЗначРезультат);
	КонецЦикла;
	
// Если один водитель, то д.б. перерыв на сон в конце рабочего дня. Приращение = (24часа - ПродолжительностьРабочегоВремениДеньЧ).
// Конец рабочего дня не учитывает смещения по перерывам, т.к. перерывы входят в продолжительность рабочего дня
	Если НЕ НесколькоВодителей Тогда
		НоваяСтрока = ТаблицаРезультат.Добавить();	
		НоваяСтрока.ВремяНачалаПерерыва = ПродолжительностьРабочегоВремениДень;
		НоваяСтрока.Приращение 			= (24 - Правило.ПродолжительностьРабочегоВремениДеньЧ) * КоэффициентПереводаИзЧасов;
		НоваяСтрока.НовыеСутки 			= Истина;
	КонецЕсли;
	
	Возврат ТаблицаРезультат;
	
КонецФункции

// Функция рассчитывает новое время (прибытия/убытия) с учетом отдыха
Функция РассчитатьПриращениеВремениКТочке(СтруктураПерерывовИПриращений, Знач ПлановоеПрибытиеВСледующуюТочку, НачалоРейса, КоэффициентПереводаИзЧасов = 3600) Экспорт
	
	ТаблицаПерерывовИПриращений	= СтруктураПерерывовИПриращений.ТаблицаПерерывовИПриращений;
	Если НЕ ТаблицаПерерывовИПриращений.Количество() Тогда
		Возврат ПлановоеПрибытиеВСледующуюТочку;
	КонецЕсли;
	
	СтруктураПерерывовИПриращений.ДатаРасчета = НачалоДня(НачалоРейса);
	
	ПродолжительностьРабочейНеделиС		= СтруктураПерерывовИПриращений.ПродолжительностьРабочейНеделиС;	
	ПродолжительностьКалендарнойНеделиС	= СтруктураПерерывовИПриращений.ПродолжительностьКалендарныхСутокС * 7; //
	ПродолжительностьРабочегоДняС 		= СтруктураПерерывовИПриращений.ПродолжительностьРабочегоДняС;
	Если Не ЗначениеЗаполнено(ПродолжительностьРабочейНеделиС) Тогда
		ВызватьИсключение "Не указана продолжительность рабочей недели";
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ПродолжительностьРабочегоДняС) Тогда
		ВызватьИсключение "Не указана продолжительность рабочего дня";
	КонецЕсли; 
	ВремяНаДорогуС 		= СтруктураПерерывовИПриращений.ПлановоеВремяДоТочки;
	ОбщееВремяВПутиС 	= 0;	
	ОстатокС 			= ВремяНаДорогуС; 
	
	Если ОстатокС >= ПродолжительностьРабочейНеделиС Тогда
	
		Пока ОстатокС > 0 Цикл
			ОбщееВремяВПутиС 	= ОбщееВремяВПутиС + ПродолжительностьКалендарнойНеделиС;				
			ОстатокС			= ОстатокС - ПродолжительностьРабочейНеделиС; 	
			
			СтруктураПерерывовИПриращений.ДатаРасчета 		= СтруктураПерерывовИПриращений.ДатаРасчета + ПродолжительностьКалендарнойНеделиС;
			СтруктураПерерывовИПриращений.ФактПредыдущий 	= 0;
			
			Если ОстатокС >= ПродолжительностьРабочейНеделиС Тогда
				Продолжить;
			ИначеЕсли ОстатокС > 0 Тогда
				// Механизм внутринедельного рассчета
				ВнутриНедельныйРасчет(ОстатокС, ОбщееВремяВПутиС, СтруктураПерерывовИПриращений);
			КонецЕсли;
		КонецЦикла;		
	Иначе
		// Механизм внутринедельного расчета
		ВнутриНедельныйРасчет(ОстатокС, ОбщееВремяВПутиС, СтруктураПерерывовИПриращений);
	КонецЕсли;
	
	ВремяРезультат = НачалоРейса + ОбщееВремяВПутиС;
	
	//НовоеРасчетноеВремя = ВремяРезультат - СтруктураПерерывовИПриращений.ДатаРасчета;
	НовоеРасчетноеВремя = ВремяРезультат - НачалоРейса;
	Если НовоеРасчетноеВремя > ПродолжительностьРабочегоДняС Тогда

		//Если НачалоДня(ВремяРезультат) = СтруктураПерерывовИПриращений.ДатаРасчета Тогда
		//	ВремяРезультат = ВремяРезультат + (24*КоэффициентПереводаИзЧасов - ПродолжительностьРабочегоДняС);
		//КонецЕсли;

		СтруктураПерерывовИПриращений.НовыеСутки = Истина;
	КонецЕсли;

	Возврат ВремяРезультат;
	
КонецФункции

// Функция рассчитывает приращение к времени по суточно
Процедура ВнутриНедельныйРасчет(ОстатокС, ОбщееВремяВПутиС, СтруктураПерерывовИПриращений)
	
	ПродолжительностьРабочихСутокС		= СтруктураПерерывовИПриращений.ПродолжительностьРабочегоДняС - СтруктураПерерывовИПриращений.ПродолжительностьОтдыхаВРабочемДнеС;	
	ПродолжительностьКалендарныхСутокС	= СтруктураПерерывовИПриращений.ПродолжительностьКалендарныхСутокС;	

	Пока ОстатокС > 0 Цикл
		Если ОстатокС >= ПродолжительностьРабочихСутокС Тогда 			//
			ОбщееВремяВПутиС    = ОбщееВремяВПутиС + ПродолжительностьКалендарныхСутокС;
			ОстатокС			= ОстатокС - ПродолжительностьРабочихСутокС;
			// +++.17/02/27-13:36:04.<УП>
			ОбщееВремяВПутиС = ОбщееВремяВПутиС + СтруктураПерерывовИПриращений.ФактПредыдущий;
			// ---.17/02/27-13:36:04.<УП>
			СтруктураПерерывовИПриращений.ДатаРасчета 		= СтруктураПерерывовИПриращений.ДатаРасчета + ПродолжительностьКалендарныхСутокС;
			СтруктураПерерывовИПриращений.ФактПредыдущий	= 0;
			
		ИначеЕсли ОстатокС > 0 Тогда
			// механизм рассчета внутрисуточного отдыха
			ВнутрисуточныйРасчет(ОстатокС, ОбщееВремяВПутиС, СтруктураПерерывовИПриращений);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Функция рассчитывает приращение к времени согласно таблице перерывов и приращений
Процедура ВнутрисуточныйРасчет(ОстатокС, ОбщееВремяВПутиС, СтруктураПерерывовИПриращений)
	
	ПродолжительностьРабочегоДняС 	= СтруктураПерерывовИПриращений.ПродолжительностьРабочегоДняС;
	ТаблицаПерерывовИПриращений		= СтруктураПерерывовИПриращений.ТаблицаПерерывовИПриращений;
	
// Если плановое время прибытия не превышает рабочий день, то учтем ранее выполненные приращения и пересчитаем новые
	ВремяДляРасчетаОтдыхаСек = СтруктураПерерывовИПриращений.ФактПредыдущий + ОстатокС;
	ОтдыхТекущий = 0;
	
	// Рассчитаем время приращения за все перерывы	
	Для Каждого СтрокаПриращение Из ТаблицаПерерывовИПриращений Цикл
		Если ВремяДляРасчетаОтдыхаСек <= СтрокаПриращение.ВремяНачалаПерерыва Тогда
			Прервать;
		КонецЕсли;
		ОтдыхТекущий = ОтдыхТекущий + СтрокаПриращение.Приращение;
	КонецЦикла;
	
	НовыеСутки 			 = СтруктураПерерывовИПриращений.НовыеСутки;
	ФактПредыдущий 		 = СтруктураПерерывовИПриращений.ФактПредыдущий;
	ОтдыхПредыдущий 	 = СтруктураПерерывовИПриращений.ОтдыхПредыдущий;
	ПлановоеВремяДоТочки = ОстатокС;
	
	//Факт[i] = 	   					  Факт[i-1] 	 + Отдых[i] 	- Отдых[i-1] 						+ ПлановоеВремяДоТочки[i];	
	ОбщееВремяВПутиС = ОбщееВремяВПутиС + ФактПредыдущий + ОтдыхТекущий - ?(НовыеСутки, 0, ОтдыхПредыдущий) + ПлановоеВремяДоТочки;
	
	СтруктураПерерывовИПриращений.ОтдыхПредыдущий = ОтдыхТекущий;
	
	ОстатокС = 0;
	
КонецПроцедуры

// Контроль заполнения обязательных реквизитов в правиле режима труда и отдыха
Функция ПроверитьОбязательныеПараметрыПравилРежимовТруда(Правила)
	
	Отказ = Ложь;
	
	Если НЕ ЗначениеЗаполнено(Правила) Тогда
		//Сообщить("");
		Отказ = Истина;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Правила.ПродолжительностьРабочегоВремениДеньЧ) Тогда
		//Сообщить("");
		Отказ = Истина;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Правила.ПерерывОбедОтдыхКоличество) И (ЗначениеЗаполнено(Правила.ПерерывОбедОтдыхПериодичностьЧ) + ЗначениеЗаполнено(Правила.ПерерывОбедОтдыхПродолжительностьМ)) <> 2 Тогда
		Если НЕ ЗначениеЗаполнено(Правила.ПерерывОбедОтдыхПериодичностьЧ) Тогда
			//Сообщить("");
			Отказ = Истина;
		КонецЕсли;
		
		Если НЕ ЗначениеЗаполнено(Правила.ПерерывОбедОтдыхПродолжительностьМ) Тогда
			//Сообщить("");
			Отказ = Истина;
		КонецЕсли;
	КонецЕсли;		
	
	Если (ЗначениеЗаполнено(Правила.СпециальныйПерерывПервыйПериодичностьЧ) + ЗначениеЗаполнено(Правила.СпециальныйПерерывПервыйПродолжительностьМ)) = 1 Тогда
		Если НЕ ЗначениеЗаполнено(Правила.СпециальныйПерерывПервыйПериодичностьЧ) Тогда
			//Сообщить("");
			Отказ = Истина;
		КонецЕсли;
		Если НЕ ЗначениеЗаполнено(Правила.СпециальныйПерерывПервыйПродолжительностьМ) Тогда
			//Сообщить("");
			Отказ = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если (ЗначениеЗаполнено(Правила.СпециальныйПерерывПоследующиеПериодичностьЧ) + ЗначениеЗаполнено(Правила.СпециальныйПерерывПоследующиеПродолжительностьМ)) = 1 Тогда
		Если НЕ ЗначениеЗаполнено(Правила.СпециальныйПерерывПоследующиеПериодичностьЧ) Тогда
			//Сообщить("");
			Отказ = Истина;
		КонецЕсли;
		
		Если НЕ ЗначениеЗаполнено(Правила.СпециальныйПерерывПоследующиеПродолжительностьМ) Тогда
			//Сообщить("");
			Отказ = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат НЕ Отказ;
	
КонецФункции

#КонецОбласти

#КонецОбласти