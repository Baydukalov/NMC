
#Область ПрограммныйИнтерфейс

// Функция - Получить объект XDTO
//
// Параметры:
//  ФорматСообщения	 - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  ТелоСообщения	 - Строка - Текстовое представление сообщения в указанном формате.
// 
// Возвращаемое значение:
//  ОбъектXDTO - объект сформированный фабрикойXDTO из исходного текста. В случае невозможности преобразования возвращается Неопределено.  
//
Функция ПолучитьОбъектXDTO(ФорматСообщения, ТелоСообщения, типобъекта = неопределено) Экспорт
	текОбъект = Неопределено;
	Попытка
		текЧтение = ПолучитьОбъектПотоковогоЧтения(ФорматСообщения, ТелоСообщения);
		Если НЕ текЧтение = Неопределено тогда
			текОбъект = ПрочитатьОбъектИзПотока(ФорматСообщения, текЧтение, типобъекта);
		КонецЕсли;
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ЗаписьЖурналаРегистрации("Datareon.ПолучитьОбъектСообщения", УровеньЖурналаРегистрации.Ошибка, Метаданные.ОбщиеМодули.сшпОбщегоНазначения,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
	КонецПопытки;
	Возврат текОбъект;
КонецФункции	

// Функция - Сформировать сообщение ESB
//
// Параметры:
//  Фабрика	 - ФабрикаXDTO - фаббрика которая содержит необходимые форматы сообщений. Для отправкии сообщений другим системам необходимо использовать фабрику полученную из текущего прокси-соединения.
//  Пакет	 - Структура - Структура содержащая поля соответствующие описанию формата объекта Message1C.
// 
// Возвращаемое значение:
//  ОбъектXDTO - обект типа Message1C.
//
Функция СформироватьСообщениеESB(Фабрика, Пакет) Экспорт
	ТипСообщение 					= Фабрика.Тип("http://esb.axelot.ru", "Message");
	Если ТипЗнч(Пакет) = Тип("Массив") Тогда 
		ТипПакета 						= Фабрика.Тип("http://esb.axelot.ru", "Messages");
		xdtoПакет 						= Фабрика.Создать(ТипПакета);
		Для Каждого Сообщение Из Пакет Цикл 
			xdtoСообщение 						= Фабрика.Создать(ТипСообщение);
			ЗаполнитьПакетXDTO(Фабрика, xdtoСообщение, Сообщение);
			xdtoПакет.Message.Добавить(xdtoСообщение);
		КонецЦикла;
	Иначе
		xdtoПакет 						= Фабрика.Создать(ТипСообщение);
		ЗаполнитьПакетXDTO(Фабрика, xdtoПакет, Пакет);
	КонецЕсли;

	Возврат xdtoПакет;
КонецФункции

Процедура ЗаполнитьПакетXDTO(Фабрика, xdtoПакет, Сообщение)
	xdtoПакет.Id 					= Фабрика.Создать(Фабрика.Тип("http://schemas.microsoft.com/2003/10/Serialization/", "guid"), Строка(Сообщение.Id));
	xdtoПакет.ClassId 				= Сообщение.ClassId;
	xdtoПакет.Type					= Сообщение.Type;
	xdtoПакет.CreationTime			= ?(Сообщение.CreationTime = Неопределено,ТекущаяДата(), Сообщение.CreationTime);
	xdtoПакет.Body 					= Сообщение.Body;		
	xdtoПакет.NeedAcknowledgment	= Сообщение.NeedAcknowledgment;
	xdtoПакет.ReplyTo 				= Сообщение.ReplyTo;
	xdtoПакет.Source 				= Сообщение.Source;	
	xdtoПакет.CorrelationId 		= ?(ЗначениеЗаполнено(Сообщение.CorrelationId), Фабрика.Создать(Фабрика.Тип("http://schemas.microsoft.com/2003/10/Serialization/", "guid"), Строка(Сообщение.CorrelationId)), Неопределено);
	xdtoПакет.Properties 			= Фабрика.Создать(Фабрика.Тип("http://esb.axelot.ru", "ArrayOfMessageProperty"));
	Если ТипЗнч(Сообщение.Properties) = Тип("Структура") тогда
		Для каждого свойство из Сообщение.Properties цикл
			xdtoПакет.Properties.MessageProperty.Добавить(ДобавитьСвойствоСообщения(Фабрика, свойство.Ключ, свойство.Значение));
		КонецЦикла;	
	КонецЕсли;
	Если ТипЗнч(Сообщение.Receivers) = Тип("Массив") И Сообщение.Receivers.Количество() Тогда 
		xdtoПакет.Receivers 			= Фабрика.Создать(Фабрика.Тип("http://esb.axelot.ru", "Receivers"));
		Для Каждого ЭлементМассива Из Сообщение.Receivers Цикл 
			xdtoПакет.Receivers.Receiver.Добавить(ЭлементМассива);
		КонецЦикла;
	Иначе
		xdtoПакет.Receivers 			= Фабрика.Создать(Фабрика.Тип("http://esb.axelot.ru", "Receivers"));
	КонецЕсли;
КонецПроцедуры

// Функция - Добавить свойство сообщения
//
// Параметры:
//  имя		 - Строка - Имя свойства 
//  значение - Число,Строка,Булево - значение свойства. Поддерживаются примитивные типы. 
// 
// Возвращаемое значение:
//  ОбъектXDTO - объект XDTO с типом MessageProperty.
//
Функция ДобавитьСвойствоСообщения(фабрика, имя, значение)
	xmlСтрока = "
	|<MessageProperty xmlns=""http://esb.axelot.ru"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"">
	|	<Name>" + имя + "</Name>
	|	<Value>
	|		" + ДобавитьЗначение(значение) + "
	|	</Value>
	|</MessageProperty>";
	чтениеXML = новый ЧтениеXML;
	чтениеXML.УстановитьСтроку(xmlСтрока);
	Возврат фабрика.ПрочитатьXML(чтениеXML, фабрика.Тип("http://esb.axelot.ru", "MessageProperty"));
КонецФункции

// Функция - Добавить значение
//
// Параметры:
//  значение - Число,Строка,Булево - значение свойства. Поддерживаются примитивные типы .
// 
// Возвращаемое значение:
//  Строка - строка подстановки для формирования представления xml.
//
Функция ДобавитьЗначение(значение)
	типЗначения = ТипЗнч(значение);
	Если типЗначения = Тип("Число") тогда
		Возврат ДобавитьЧисловоеЗначение(значение);
	ИначеЕсли типЗначения = Тип("Строка") тогда
		Возврат  ДобавитьСтроковоеЗначение(значение);
	КонецЕсли;	
	Возврат ДобавитьБулевоЗначение(значение);	
КонецФункции

// Функция - Добавить числовое значение
//
// Параметры:
//  значение - Число - значение свойства.
// 
// Возвращаемое значение:
//  Строка - строка подстановки для формирования представления xml.
//
Функция ДобавитьЧисловоеЗначение(значение)
	Возврат "
	|<IntegerValues>
	|	<int xmlns=""http://schemas.microsoft.com/2003/10/Serialization/Arrays"">" + XMLСтрока(значение) + "</int>
	|</IntegerValues>
	|<Type>Integer</Type>";
КонецФункции

// Функция - Добавить строковое значение
//
// Параметры:
//  значение - Строка - значение свойства.
// 
// Возвращаемое значение:
//  Строка - строка подстановки для формирования представления xml.
//
Функция ДобавитьСтроковоеЗначение(значение)
	Возврат "
	|<StringValues>
	|	<string xmlns=""http://schemas.microsoft.com/2003/10/Serialization/Arrays"">" + XMLСтрока(значение) + "</string>
	|</StringValues>
	|<Type>String</Type>";
КонецФункции

// Функция - Добавить булево значение
//
// Параметры:
//  значение - Булево - значение свойства.
// 
// Возвращаемое значение:
//  Строка - строка подстановки для формирования представления xml.
//
Функция ДобавитьБулевоЗначение(значение)
	Возврат "
	|<BooleanValues>
	|	<boolean xmlns=""http://schemas.microsoft.com/2003/10/Serialization/Arrays"">" + XMLСтрока(значение) + "</boolean>
	|</BooleanValues>
	|<Type>Boolean</Type>";
КонецФункции

// Функция - Сформировать сообщение ESB HTTP
//
// Параметры:
//  Фабрика	 - ФабрикаXDTO - фаббрика которая содержит необходимые форматы сообщений. Для отправкии сообщений другим системам необходимо использовать фабрику полученную из текущего прокси-соединения.
//  Пакет	 - Структура - Структура содержащая поля соответствующие описанию формата объекта Message1C.
// 
// Возвращаемое значение:
//  Строка - ОбъектXDTO типа Message1C сериализованный в формат сообщения.
//
Функция СформироватьСообщениеESB_HTTP(Фабрика, Пакет) Экспорт
	xdtoПакет = СформироватьСообщениеESB(Фабрика, Пакет);
	Возврат ЗаписатьОбъектВПоток(сшпФункциональныеОпции.ФорматСообщения(), xdtoПакет, фабрика);
КонецФункции

// Функция - Преобразовать структуру по формату
//
// Параметры:
//  Формат		 - Перечисление.сшпФорматыСообщений - текущий формат сообщения
//  сткДанные	 - Структура - данные которые будут преобразованны в указанный формат.
// 
// Возвращаемое значение:
//  Строка - данные структуры преобразованные в указанный формат.
//
Функция ПреобразоватьСтруктуруПоФормату(Формат = Неопределено, сткДанные) Экспорт
	Если Формат = Неопределено тогда
		Формат = сшпФункциональныеОпции.ФорматСообщения();
	КонецЕсли;	
	Если Формат = Перечисления.сшпФорматыСообщений.XML тогда
		Возврат сшпФункцииРаботыXML.СформироватьXML(сткДанные);
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON тогда
		Возврат сшпФункцииРаботыJSON.СформироватьJSON(сткДанные);
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset тогда
		Возврат сшпФункцииРаботыFastInfoset.СформироватьFastInfoset(сткДанные);
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Функция - Сериализовать объект
//
// Параметры:
//  Формат		 - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  ОбъектИсточник	 - ЛюбаяСсылка, ЛюбойОбъект	 - объект который необходимо сериализовать в указанный формат.
// 
// Возвращаемое значение:
//  Строка - данные объекта преобразованные в указанный формат. 
//
Функция СериализоватьОбъект(Формат, ОбъектИсточник) Экспорт
	текОбъект = Неопределено;
	Попытка
		Если Формат = Перечисления.сшпФорматыСообщений.XML тогда
			текОбъект = сшпФункцииРаботыXML.СериализоватьОбъект(ОбъектИсточник);
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON тогда
			текОбъект = сшпФункцииРаботыJSON.СериализоватьОбъект(ОбъектИсточник);
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset тогда
			текОбъект = сшпФункцииРаботыFastInfoset.СериализоватьОбъект(ОбъектИсточник);
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации("Datareon. Сериализация объекта", УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	КонецПопытки;
	Возврат текОбъект;
КонецФункции	

// Функция - Десериализовать объект
//
// Параметры:
//  Формат		 - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  ОбъектИсточник	 - Строка - описание объект в указанном формате.
// 
// Возвращаемое значение:
//  ЛюбаяСсылка, ЛюбойОбъект	 - объект десериализованный из указанного формата. 
//
Функция ДесериализоватьОбъект(Формат, ОбъектИсточник) Экспорт
	текОбъект = Неопределено;
	Попытка
		Если Формат = Перечисления.сшпФорматыСообщений.XML тогда
			текОбъект = сшпФункцииРаботыXML.ДесериализоватьОбъект(ОбъектИсточник);
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON тогда
			текОбъект = сшпФункцииРаботыJSON.ДесериализоватьОбъект(ОбъектИсточник);
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset тогда
			текОбъект = сшпФункцииРаботыFastInfoset.ДесериализоватьОбъект(ОбъектИсточник);
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации("Datareon. Десериализация объекта", УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	КонецПопытки;
	Возврат текОбъект;
КонецФункции	

// Функция - Получить объект потокового чтения
//
// Параметры:
//  Формат		 - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  ЧитаемаяСтрока	 - 	 - .
// 
// Возвращаемое значение:
// ЧтениеXML, ЧтениеFastInfoset, ЧтениеJSON  - объект потокового чтения заданного формата.
//
Функция ПолучитьОбъектПотоковогоЧтения(Формат, ЧитаемаяСтрока) Экспорт
	текОбъект = Неопределено;
	Если Формат = Перечисления.сшпФорматыСообщений.XML тогда
		текОбъект = сшпФункцииРаботыXML.ПолучитьОбъектПотоковогоЧтения(ЧитаемаяСтрока);
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON тогда
		текОбъект = сшпФункцииРаботыJSON.ПолучитьОбъектПотоковогоЧтения(ЧитаемаяСтрока);
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset тогда
		текОбъект = сшпФункцииРаботыFastInfoset.ПолучитьОбъектПотоковогоЧтения(ЧитаемаяСтрока);
	КонецЕсли;
	Возврат текОбъект;
КонецФункции

// Функция - Получить объект потоковой записи
//
// Параметры:
//  Формат		 - Перечисление.сшпФорматыСообщений - текущий формат сообщения.
// 
// Возвращаемое значение:
// ЗаписьXML, ЗаписьFastInfoset, ЗаписьJSON  - объект потоковой записи заданного формата.
//
Функция ПолучитьОбъектПотоковойЗаписи(Формат) Экспорт
	текОбъект = Неопределено;
	Если Формат = Перечисления.сшпФорматыСообщений.XML тогда
		текОбъект = сшпФункцииРаботыXML.ПолучитьОбъектПотоковойЗаписи();
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON тогда
		текОбъект = сшпФункцииРаботыJSON.ПолучитьОбъектПотоковойЗаписи();
	ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset тогда
		текОбъект = сшпФункцииРаботыFastInfoset.ПолучитьОбъектПотоковойЗаписи();
	КонецЕсли;
	Возврат текОбъект;
КонецФункции	

// Функция - Прочитать объект из потока
//
// Параметры:
//  Формат	- Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  Поток	- Строка - строка описания объекта в заданном формате.
// 
// Возвращаемое значение:
//  ЛюбаяСсылка, ЛюбойОбъект	 - объект прочитанный фабрикой XDTO из указанного формата. 
//
Функция ПрочитатьОбъектИзПотока(Формат, Поток, типобъекта) Экспорт
	текОбъект = Неопределено;
	Попытка
		Если Формат = Перечисления.сшпФорматыСообщений.XML тогда
			текОбъект = сшпФункцииРаботыXML.ПрочитатьОбъектИзПотока(Поток, типобъекта);
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON тогда
			текОбъект = сшпФункцииРаботыJSON.ПрочитатьОбъектИзПотока(Поток, типобъекта);
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset тогда
			текОбъект = сшпФункцииРаботыFastInfoset.ПрочитатьОбъектИзПотока(Поток, типобъекта);
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации("Datareon. Формирование объекта XDTO", УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	КонецПопытки;
	Возврат текОбъект;
КонецФункции

// Функция - Записать объект в поток
//
// Параметры:
//  Формат	- Перечисление.сшпФорматыСообщений - текущий формат сообщения.
//  Объект 	- ЛюбаяСсылка, ЛюбойОбъект	 - объект который необходимо сериализовать в указанный формат.
//  фабрика	- ФабрикаXDTO - фабрика XDTO для преобразования объекта в строку указанного формата. 
// 
// Возвращаемое значение:
// Строка  -  Объект преобразованный в строку заданного формата.
//
Функция ЗаписатьОбъектВПоток(формат, объект, фабрика = Неопределено) Экспорт
	стрПредставление = "";
	Попытка
		Если Формат = Перечисления.сшпФорматыСообщений.XML тогда
			стрПредставление = сшпФункцииРаботыXML.ЗаписатьОбъектВПоток(Объект, фабрика);
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.JSON тогда
			стрПредставление = сшпФункцииРаботыJSON.ЗаписатьОбъектВПоток(Объект, фабрика);
		ИначеЕсли Формат = Перечисления.сшпФорматыСообщений.FastInfoset тогда
			стрПредставление = сшпФункцииРаботыFastInfoset.ЗаписатьОбъектВПоток(Объект, фабрика);
		КонецЕсли;
	Исключение
		ЗаписьЖурналаРегистрации("Datareon. Запись объекта XDTO в файл", УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));		
	КонецПопытки;
	Возврат стрПредставление;
КонецФункции

// Процедура - Ожидание
//
// Параметры:
//  Длительность - Число - длительность ожидания в секундах.
//
Процедура Ожидание(Длительность) Экспорт
	
	Идентификатор = Новый УникальныйИдентификатор;
	
	НачатьТранзакцию();
	
	Блокировка = Новый БлокировкаДанных;	
	Элемент = Блокировка.Добавить("РегистрСведений.сшпБлокировкаОчереди");
	Элемент.Режим = РежимБлокировкиДанных.Исключительный;
	Элемент.УстановитьЗначение("Идентификатор", Идентификатор);	
	Блокировка.Заблокировать();
	
	мсвПараметров = Новый Массив;
	мсвПараметров.Добавить(Идентификатор);
	Задание = ФоновыеЗадания.Выполнить("сшпОбщегоНазначения.ВыполнитьПаузу", мсвПараметров,, "Выполнить паузу " + Длительность + " сек.");
	
	Попытка
		Задание.ОжидатьЗавершения(Длительность);
	Исключение
	КонецПопытки;             
	
	ОтменитьТранзакцию();
	
КонецПроцедуры

// Процедура - Выполнить паузу
//
// Параметры:
//  Идентификатор	 - УникальныйИдентификатор - идентификатор сессии ожидания.
//
Процедура ВыполнитьПаузу(Идентификатор) Экспорт
	
	НачатьТранзакцию();
	Блокировка = Новый БлокировкаДанных;
	
	Элемент = Блокировка.Добавить("РегистрСведений.сшпБлокировкаОчереди");
	Элемент.Режим = РежимБлокировкиДанных.Исключительный;
	Элемент.УстановитьЗначение("Идентификатор", Идентификатор);
	
	Попытка
		Блокировка.Заблокировать();
	Исключение
	КонецПопытки;
	ОтменитьТранзакцию();
	
КонецПроцедуры

// Функция - Сформировать структуру пакета
//
// Параметры:
//  ТипПакета	 - Строка - тип информационного пакета. 
//  Класс		 - Строка - класс информационного пакета. 
//  ТелоПакета	 - Строка - секция Body информационного пакета. 
// 
// Возвращаемое значение:
// Структура  - структура повторяющая структуру объекта XDTO типа Message1C.
//
Функция СформироватьСтруктуруПакета(ТипПакета = "DTP", Класс = "", ТелоПакета = "") Экспорт
	сткПакет = Новый Структура;
	сткПакет.Вставить("Id", Строка(Новый УникальныйИдентификатор));
	сткПакет.Вставить("Type", ТипПакета);
	сткПакет.Вставить("ClassId", Класс);
	сткПакет.Вставить("Body", ТелоПакета);
	сткПакет.Вставить("CreationTime", ТекущаяУниверсальнаяДата());
	сткПакет.Вставить("NeedAcknowledgment", Ложь);
	сткПакет.Вставить("Properties", Неопределено);
	сткПакет.Вставить("Receivers", Новый Массив);
	сткПакет.Вставить("ReplyTo", Неопределено);
	сткПакет.Вставить("Source", Неопределено);	
	сткПакет.Вставить("CorrelationId", Неопределено);	
	Возврат сткПакет;
КонецФункции

// Функция - Получить количество потоков
//
// Параметры:
//  ИмяПараметра		 - Строка - имя параметра по которому выполняется поиск фоновых заданий.
//  ЗначениеПараметра	 - Массив - значения для отбора по параметру.
// 
// Возвращаемое значение:
// Число  - количество активных фоновых заданий.
//
Функция ПолучитьКоличествоПотоков(ИмяПараметра, ЗначениеПараметра) Экспорт
	сткУсловияПоиска = Новый Структура;
	сткУсловияПоиска.Вставить(ИмяПараметра, ЗначениеПараметра);
	сткУсловияПоиска.Вставить("Состояние", СостояниеФоновогоЗадания.Активно);
	мсвОбработчики = ФоновыеЗадания.ПолучитьФоновыеЗадания(сткУсловияПоиска);
	Возврат мсвОбработчики.Количество();
КонецФункции	

// Процедура - Запустить обработку потоков
//
Процедура ЗапуститьОбработкуПотоков() Экспорт
	сшпОбщегоНазначения.ЗапуститьОбработчикОчереди("УправлениеПуломОбработчиков");
КонецПроцедуры

// Функция - ПеревестиДатувЧисло
// 
// Возвращаемое значение:
// Число  - Дата изменения + Задержка.
//
Функция ПеревестиДатуВЧисло(ДатаИзменения, Задержка = 0) Экспорт
	Возврат (ДатаИзменения - Дата(2000,1,1)) + Задержка;
КонецФункции

#Если Сервер Тогда
	
// Функция - Проверить экземпляр информационной базы
// 
// Возвращаемое значение:
// Булево  - Результат проверки ИБ.
//
Функция ПроверитьЭкземплярИнформационнойБазы() Экспорт
	значениеВозврат = Истина;
	базовыйИдентификатор = сшпРаботаСКонстантами.ПолучитьЗначениеКонстанты("сшпИдентификаторИБ");
	Если ЗначениеЗаполнено(базовыйИдентификатор) тогда
		значениеВозврат = базовыйИдентификатор = НРег(СтрокаСоединенияИнформационнойБазы());
	Иначе
		сшпРаботаСКонстантами.УстановитьЗначениеКонстанты("сшпИдентификаторИБ", НРег(СтрокаСоединенияИнформационнойБазы()));
	КонецЕсли;	
	Возврат значениеВозврат;
КонецФункции

&НаСервере
// Функция - ПолучитьКлючЗаписиПоСтрокеПоиска
// 
// Возвращаемое значение:
// КлючЗаписи, Строка  - ключ записи - если запись найдена, строка - текст ошибки.
//
Функция ПолучитьКлючЗаписиПоСтрокеПоиска(ОбработчикОчереди, СтрокаПоиска) Экспорт 
	Попытка
		ИдентификаторСообщения = Новый УникальныйИдентификатор(СтрокаПоиска);
	Исключение
		Возврат "Для поиска требуется ввести в строке уникальный идентификатор сообщения полностью";
	КонецПопытки;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	сшпОчередьСообщений.ИдентификаторСообщения
		|ИЗ
		|	РегистрСведений."+ ОбработчикОчереди + " КАК сшпОчередьСообщений
		|ГДЕ
		|	сшпОчередьСообщений.ИдентификаторСообщения = &ИдентификаторСообщения";
	
	Запрос.УстановитьПараметр("ИдентификаторСообщения", ИдентификаторСообщения);
	РезультатЗапроса = Запрос.Выполнить();

	Если РезультатЗапроса.Пустой() Тогда 
		Возврат "Сообщение не найдено";
	Иначе
		Возврат РегистрыСведений[ОбработчикОчереди].СоздатьКлючЗаписи(Новый Структура("ИдентификаторСообщения", ИдентификаторСообщения));
	КонецЕсли;
КонецФункции

#КонецЕсли

// Функция - Получить параметры сообщения структурой
//
// Параметры:
//  Сообщение	 - ОбъектXDTO - объект типа Message1C 
// 
// Возвращаемое значение:
//  Структура - структура с дополнительными свойствами сообщения.
//
функция ПолучитьПараметрыСообщенияСтруктурой(Сообщение) Экспорт
	структураПараметры = Новый Структура;
	Если НЕ Сообщение = Неопределено тогда
		xdtoСвойства = Сообщение.Properties.Последовательность();
		Если xdtoСвойства = Неопределено тогда // В зависимости от вида сериализации это может быть список или последовательность.
			xdtoСвойства = Сообщение.Properties.ПолучитьСписок("MessageProperty");
			Для каждого текПараметр из xdtoСвойства цикл
				структураПараметры.Вставить(текПараметр.Name, ПолучитьЗначениеСвойстваСообщения(текПараметр)); 
			КонецЦикла;
		Иначе 	
			количествоПараметры = xdtoСвойства.Количество();		
			Если количествоПараметры > 0 тогда
				Для Индекс = 0 по количествоПараметры - 1 цикл
					текПараметр = xdtoСвойства.ПолучитьЗначениеXDTO(Индекс);
					структураПараметры.Вставить(текПараметр.Name, ПолучитьЗначениеСвойстваСообщения(текПараметр)); 
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Возврат структураПараметры;
КонецФункции

// Функция - Получить значение свойства сообщения
//
// Параметры:
//  свойство - ОбъектXDTO - свойство сообщения
// 
// Возвращаемое значение:
//  Любое значение - значение свойства сообщения 
//
Функция ПолучитьЗначениеСвойстваСообщения(свойство)
	типСвойства = свойство.Получить("Value/Type");
	типСвойства = ?(типСвойства = "Double", "Boolean", типСвойства); // Временная заглушка для обхода ошибки!!!
	типСвойства1С = ?(НРег(типСвойства) = "integer", "Number", типСвойства); 
	узел = свойство.Получить("Value/"+типСвойства+"Values/");
	ЗначениеСвойства = узел.Получить(узел.Свойства().Get(0).Имя);
	Возврат ?(ЗначениеСвойства = null или ЗначениеСвойства = Неопределено, Неопределено, XMLЗначение(Тип(типСвойства1С), ЗначениеСвойства));
КонецФункции

// Процедура - Запустить обработчик очереди
//
// Параметры:
//  обработчикочереди	 - Строка - имя функции обработчика.
//  имямодуля			 - Строка - имя модуля в котором размещена функция обработчик.
//
Процедура ЗапуститьОбработчикОчереди(обработчикочереди, имямодуля = "сшпОбслуживаниеОчередей") Экспорт
		Попытка
			ФоновыеЗадания.Выполнить(имямодуля + "." + обработчикочереди,, обработчикочереди, обработчикочереди);
		Исключение
			// Запускаем фоновое задание со статическим ключем. Запуск других экземпляров должен заканчиваться ошибкой (паттерн синглтон).
		КонецПопытки;
КонецПроцедуры

#КонецОбласти
