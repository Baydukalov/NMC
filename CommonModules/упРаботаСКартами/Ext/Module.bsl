#Область ПрограммныйИнтерфейс

// Нужно переделать. Вызов есть из защищенного модуля.
//  Возвращает путь между Адресами.
//  Получает маршрут (путь) между двумя адресами и представления адресов.
//
// Параметры:
//  НачальнаяТочка	 - СправочникСсылка.упАдреса	 - Начальный адрес запрашиваемого маршрута.
//  КонечнаяТочка	 - СправочникСсылка.упАдреса	 - Конечный адрес запрашиваемого маршрута.
// 
// Возвращаемое значение:
//  Структура - структура:
//  * НачальноеПредставление 	- Строка	- Представление начального адреса.
//  * КонечноеПредставление	- Строка	- Представление конечного адреса.
//  * Путь				- Строка	- Маршрут между начальным и конечным адресом.
//
Функция ПолучитьПутьМеждуТочками(НачальнаяТочка,КонечнаяТочка) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	упАдреса.Широта КАК НачальнаяШирота,
	|	упАдреса.Долгота КАК НачальнаяДолгота,
	|	упАдреса.ГеографическаяЗона.Представление КАК НачальноеПредставление
	|ПОМЕСТИТЬ НачальнаяТочка
	|ИЗ
	|	Справочник.упАдреса КАК упАдреса
	|ГДЕ
	|	упАдреса.Ссылка = &НачальнаяТочка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	упАдреса.Широта КАК КонечнаяШирота,
	|	упАдреса.Долгота КАК КонечнаяДолгота,
	|	упАдреса.ГеографическаяЗона.Представление КАК КонечноеПредставление
	|ПОМЕСТИТЬ КонечнаяТочка
	|ИЗ
	|	Справочник.упАдреса КАК упАдреса
	|ГДЕ
	|	упАдреса.Ссылка = &КонечнаяТочка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	упРасстоянияМеждуТочками.Путь,
	|	НачальнаяТочка.НачальноеПредставление,
	|	спрКонечнаяТочка.КонечноеПредставление
	|ИЗ
	|	КонечнаяТочка КАК спрКонечнаяТочка
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.упРасстоянияМеждуТочками КАК упРасстоянияМеждуТочками
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ НачальнаяТочка КАК НачальнаяТочка
	|			ПО упРасстоянияМеждуТочками.НачальнаяШирота = НачальнаяТочка.НачальнаяШирота
	|				И упРасстоянияМеждуТочками.НачальнаяДолгота = НачальнаяТочка.НачальнаяДолгота
	|				И (упРасстоянияМеждуТочками.Ограничение = ЗНАЧЕНИЕ(Перечисление.упОграниченияМаршрутизаторов.ПустаяСсылка))
	|		ПО (упРасстоянияМеждуТочками.КонечнаяШирота = спрКонечнаяТочка.КонечнаяШирота)
	|			И (упРасстоянияМеждуТочками.КонечнаяДолгота = спрКонечнаяТочка.КонечнаяДолгота)
	|			И (упРасстоянияМеждуТочками.Ограничение = ЗНАЧЕНИЕ(Перечисление.упОграниченияМаршрутизаторов.ПустаяСсылка))
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НачальнаяТочка.НачальноеПредставление,
	|	спрКонечнаяТочка.КонечноеПредставление
	|ИЗ
	|	НачальнаяТочка КАК НачальнаяТочка
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ КонечнаяТочка КАК спрКонечнаяТочка
	|		ПО (ИСТИНА)";
	
	Запрос.УстановитьПараметр("НачальнаяТочка", НачальнаяТочка);
	Запрос.УстановитьПараметр("КонечнаяТочка", КонечнаяТочка);
	
	сткВозврат = Новый Структура("НачальноеПредставление, КонечноеПредставление, Путь", "", "", "");
	
	РезультатПакет = Запрос.ВыполнитьПакет();
	ВыборкаТочки = РезультатПакет[3].Выбрать();
	ВыборкаТочки.Следующий();
	сткВозврат.Вставить("НачальноеПредставление", ВыборкаТочки.НачальноеПредставление);
	сткВозврат.Вставить("КонечноеПредставление", ВыборкаТочки.КонечноеПредставление);
	
	Если РезультатПакет[2].Пустой() Тогда		
		Структура = упМаршрутизация.ПолучитьРасстояниеМеждуТочкамиПоТипуКарты(Неопределено,НачальнаяТочка,КонечнаяТочка);
		сткВозврат.Вставить("Путь", Структура.Путь);
	Иначе
		ВыборкаПуть = РезультатПакет[2].Выбрать();
		ВыборкаПуть.Следующий();
		сткВозврат.Вставить("Путь", ВыборкаПуть.Путь);
	КонецЕсли;
	Возврат сткВозврат; 
	
КонецФункции // ПолучитьДанныеМаршрута()

// Возращает массив цветовых схем по справончику "упЦветовыеСхемы".
//
// Возвращаемое значение:
//   Массив - Массив структур.
//
Функция ПолучитьЦветовыеСхемы() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	упЦветовыеСхемы.СтильЛинии.Цвет КАК Цвет,
	|	упЦветовыеСхемы.СтильЛинии.Толщина КАК Толщина,
	|	упЦветовыеСхемы.СтильЛинии.Прозрачность КАК Прозрачность,
	|	упЦветовыеСхемы.Приоритет КАК Приоритет
	|ИЗ
	|	Справочник.упЦветовыеСхемы КАК упЦветовыеСхемы
	|ГДЕ
	|	НЕ упЦветовыеСхемы.ПометкаУдаления
	|	И упЦветовыеСхемы.ИспользоватьДляОтображенияМаршрута
	|
	|УПОРЯДОЧИТЬ ПО
	|	Приоритет";
	
	мсвЦветовыеСхемы = Новый Массив;
	текРезультат = Запрос.Выполнить();
	Если НЕ текРезультат.Пустой() Тогда
		текВыборка = текРезультат.Выбрать();
	    Пока текВыборка.Следующий() Цикл
			сткЦветоваяСхемаПоУмолчанию = Новый Структура("Цвет, Толщина, Прозрачность");
			ЗаполнитьЗначенияСвойств(сткЦветоваяСхемаПоУмолчанию, текВыборка);
			мсвЦветовыеСхемы.Добавить(сткЦветоваяСхемаПоУмолчанию);
		КонецЦикла;
	Иначе
		сткЦветоваяСхемаПоУмолчанию = Новый Структура("Цвет, Толщина, Прозрачность", Новый Цвет(255, 0, 0), 1, 0);
		мсвЦветовыеСхемы.Добавить(сткЦветоваяСхемаПоУмолчанию);
	КонецЕсли;
	
	Возврат мсвЦветовыеСхемы;
	
КонецФункции // ПолучитьЦветовыеСхемы()

#КонецОбласти

#Область УпрощениеПолигональнойЦепи

// Алгоритм Рамера — Дугласа — Пекера.

// Выполним вызов алгоритма для упрощения координат точек полигона.
//
// Параметры:
//  Координаты  - Массив - Структура ключи "Широта, Долгота", массив координат;
//  СильноеАвтоотклонение - Булево, при расчете автоотключения умножать его на 10, т.е. будет получаться сильно меньше точек;
//  Отклонение  - Число - epsilon, значение выше которого входят точки;
//
// Возвращаемое значение:
//   Массив - Структура ключи "Широта, Долгота", массив координат, в случае неудачи Неопределено.
//  
Функция ВыполнитьУпрощениеПолигональнойЦепи(Знач Координаты, СтартовоеОтклонение = Неопределено, МаксимальноеКоличествоТочек = Неопределено) Экспорт
	
	// Путь 35000 точек (Санкт-Перетербург -> Владивосток) упрощает до 6500 точек за 24 сек
	Результат = Неопределено;
	Если ТипЗнч(Координаты) = ТИП("Строка") Тогда
		// Выполнить разложение строки на массив структур.
		мсвКоординат = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Координаты, ";");
		Координаты = Новый Массив; // - массив координат.
		Для Сч = 0 По ((мсвКоординат.Количество() - 1) / 2) - 1 Цикл 
			Структура = Новый Структура; // - структура координат точки.
			Структура.Вставить("Широта", ПредставлениеКоординатыВЧисло(мсвКоординат[Сч * 2]));
			Структура.Вставить("Долгота", ПредставлениеКоординатыВЧисло(мсвКоординат[(Сч * 2) + 1]));
			Координаты.Добавить(Структура);
		КонецЦикла;
	КонецЕсли;
	Результат = УпроститьПолилиниюДоЗаданногоКоличестваТочек(Координаты, СтартовоеОтклонение, МаксимальноеКоличествоТочек);
	Возврат Результат;
	
КонецФункции // ВыполнитьУпрощениеПолигональнойЦепи()

// Безопастно преобразует строковое представление кооридинаты в число.
//
// Параметры:
//	ПредставлениеКоординаты - Строка - Координаты.
//
// Возвращаемое значение:
//	Число - значение координаты.
//
Функция ПредставлениеКоординатыВЧисло(ПредставлениеКоординаты)
	
	текОписаниеТипов = Новый ОписаниеТипов("Число");
	Возврат текОписаниеТипов.ПривестиЗначение(ПредставлениеКоординаты);
	
КонецФункции

// Выполним упрощение количества точек входящего массива координат,
//	Суть алгоритма состоит в том, чтобы по данной ломаной,
//	аппроксимирующей кривую, построить ломаную с меньшим числом точек.
//
// Параметры:
//  Координаты  - Массив - Структура ключи "Широта, Долгота", массив координат.
//  ПользовательскоеОтклонение  - Число - максимально-допустимое отклонение (е).
//  СильноеАвтоотклонение - Булево, при расчете автоотключения умножать его на 10, т.е. будет получаться сильно меньше точек
//
// Возвращаемое значение:
//   Массив - Результат выполнения.
//
Функция УпроститьПолилинию(Координаты, ПользовательскоеОтклонение, МинимальноеКоличествоТочек = Неопределено,
	// Выход
	выхОтклонение = 0) Экспорт 
	
	//               количество точек.
	// отклонение	680	19295	71640.
	//			0.5	  2	    8	  201.
	//         0.05	  4	  124	 1466.
	//        0.005	 38	 1149	 8545.
	//       0.0005	124	 4981	32648.
	
	КоличествоТочек = Координаты.Количество();
	Если ПользовательскоеОтклонение <> Неопределено И ПользовательскоеОтклонение > 0 И ПользовательскоеОтклонение < 1 Тогда
		выхОтклонение = ПользовательскоеОтклонение;
	Иначе
		выхОтклонение = 0.00001;
		Если МинимальноеКоличествоТочек <> Неопределено Тогда
			Если КоличествоТочек <= МинимальноеКоличествоТочек Тогда
				// В том случае когда точек меньше, не имеет смысла проводить упрощение.
				Возврат Координаты;
			КонецЕсли; 
			Если КоличествоТочек > МинимальноеКоличествоТочек Тогда
				выхОтклонение = выхОтклонение * (КоличествоТочек / МинимальноеКоличествоТочек);
			КонецЕсли;
		Иначе
			Если КоличествоТочек <= 1000 Тогда
				// В том случае когда точек меньше, не имеет смысла проводить упрощение.
				Возврат Координаты;
			КонецЕсли; 
			Если КоличествоТочек >= 25000 Тогда
				// При таком отклонении выборка точек должна быть меньше.
				выхОтклонение = 0.05;
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли;
	
	Массив = Новый Массив;
	КрайнийИндекс = Координаты.Количество()-1;
	ПерваяТочка = Координаты[0];
	КрайняяТочка = Координаты[КрайнийИндекс];
	Если ПерваяТочка.Широта = КрайняяТочка.Широта И ПерваяТочка.Долгота = КрайняяТочка.Долгота Тогда
		КрайнийИндекс = КрайнийИндекс - 1;
	КонецЕсли;
	
	Массив.Добавить(0);	// - добавим первый элемент.
	ВыполнитьУпрощение(Координаты, 0, КрайнийИндекс, выхОтклонение, Массив);
	Массив.Добавить(КрайнийИндекс); // - добавим крайний элемент.
	
	// - выполним сортировку индексов элементов массив координат.
	СписокЗначений = Новый СписокЗначений;
	
	СписокЗначений.ЗагрузитьЗначения(Массив);
	СписокЗначений.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	// - заполним упрощенный массив координат.
	мсвРезультат = Новый Массив;
	Для каждого текЭлемент Из СписокЗначений Цикл
		мсвРезультат.Добавить(Координаты[текЭлемент.Значение]);
	КонецЦикла;
	
	Возврат мсвРезультат;

КонецФункции // УпроститьПолилинию()

Функция УпроститьПолилиниюДоЗаданногоКоличестваТочек(Координаты, СтартовоеОтклонение = Неопределено, МаксимальноеКоличествоТочек = Неопределено) Экспорт 
	
	Отклонение = Неопределено;
	Координаты = УпроститьПолилинию(Координаты, СтартовоеОтклонение, МаксимальноеКоличествоТочек, Отклонение);
	Если МаксимальноеКоличествоТочек <> Неопределено Тогда
		Пока Координаты.Количество() > МаксимальноеКоличествоТочек Цикл
			Отклонение = Отклонение * 1.5;
			Координаты = УпроститьПолилинию(Координаты, Отклонение);
		КонецЦикла; 
	КонецЕсли;
	Возврат Координаты;
	
КонецФункции

// Выполним упрощение массива координат,
//	Если же расстояние больше ε, то алгоритм рекурсивно вызывает себя с на наборе,
//	от начальной до данной и от данной до конечной точках (что означает,
//	что данная точка будет отмечена к сохранению).
//	По окончанию всех рекурсивных вызовов выходная ломаная строится только из тех точек,
//	что были отмечены к сохранению.
//
// Параметры:
//  Координаты  - Массив - Структура ключи "Широта, Долгота", массив координат.
//  Начало  - Число - Индекс начальной позиции ячейки массива.
//  Окончание  - Число - Индекс крайней ячейки в массиве.
//  Отклонение  - Число - epsilon, значение выше которого входят точки.
//  РезультирующиеТочки  - Массив - Структура ключи "Широта, Долгота", массив координат.
//
// Возвращаемое значение:
//   Нет.
//
Функция ВыполнитьУпрощение(Координаты,Начало,Окончание,Отклонение,РезультирующиеТочки)
	
	Если Окончание > Начало+1 Тогда
		МаскД = -1; // максимальная удалённость точки от основного направления в сегменте.
		МаксИ = Начало; // индекс точки которая максимально отдалённая от осн. напр. в сегменте.
		шаг = Начало+1;
		ПерваяТочка = Координаты[Начало];
		ПерваяТочкаШирота = ПерваяТочка.Широта;
		ПерваяТочкаДолгота = ПерваяТочка.Долгота;
		ПоследняяТочка = Координаты[Окончание];
		ОсновнойВектор = Новый Структура("Широта, Долгота");
		ОсновнойВектор.Широта = ПоследняяТочка.Широта - ПерваяТочка.Широта;
		ОсновнойВектор.Долгота = ПоследняяТочка.Долгота - ПерваяТочка.Долгота;
		ОсновнойВекторШирота = ОсновнойВектор.Широта;
		ОсновнойВекторДолгота = ОсновнойВектор.Долгота;
		М12 = ОсновнойВекторШирота * ОсновнойВекторШирота + ОсновнойВекторДолгота * ОсновнойВекторДолгота;
		КореньМ12 = Sqrt(М12);
		Пока шаг < Окончание Цикл // перебираем промежуточные точки в сегменте.
			// вычисляем дистанцию от точки до основной линии в сегменте.
			ТекущаяТочка = Координаты[шаг];
			Широта1 = ТекущаяТочка.Широта - ПерваяТочкаШирота;
			Долгота1 = ТекущаяТочка.Долгота - ПерваяТочкаДолгота;
			тт = Широта1 * ОсновнойВекторШирота + Долгота1 * ОсновнойВекторДолгота;
			Дистанция = 0;
			Если тт <= 0 Тогда
				Дистанция = Sqrt(Широта1 * Широта1 + Долгота1 * Долгота1);
			ИначеЕсли тт >= М12 Тогда
				Широта1 = Широта1 + ОсновнойВекторШирота;
				Долгота1 = Долгота1 + ОсновнойВекторДолгота;
				Дистанция = Sqrt(Широта1 * Широта1 + Долгота1 * Долгота1);
			Иначе
				ТекущееЗначение = Широта1 * ОсновнойВекторДолгота - Долгота1 * ОсновнойВекторШирота;
				//Результат = ПолучитьAbs(ТекущееЗначение / Sqrt(М12));
				Дистанция = ТекущееЗначение / КореньМ12;
				Дистанция = Макс(Дистанция, -Дистанция);
			КонецЕсли;
			Если Дистанция > МаскД Тогда // если оно больше всех предыдущих, то.
				МаскД = Дистанция; // и её растояние к отрезку основ. направления в сегменте.
				МаксИ = шаг; // запоминаем индекс этой точки.
			КонецЕсли;
		    шаг = шаг + 1;
		КонецЦикла;		
		Если МаскД > Отклонение Тогда // если максимальное отклонение больше допустимого, то.
			РезультирующиеТочки.Добавить(МаксИ); // заносим эту точку в результирующий список.
			ВыполнитьУпрощение(Координаты,Начало,МаксИ,Отклонение,РезультирующиеТочки);// и делаем всё тоже для двух полученых сегментов.
			ВыполнитьУпрощение(Координаты,МаксИ,Окончание,Отклонение,РезультирующиеТочки);
		КонецЕсли;		
	КонецЕсли;
	
КонецФункции // ВыполнитьУпрощение()

#КонецОбласти